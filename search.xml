<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown简单指南</title>
    <url>/%E7%AC%94%E8%AE%B0/Markdown%E7%AE%80%E5%8D%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="MarKDown简单指南"><a href="#MarKDown简单指南" class="headerlink" title="MarKDown简单指南"></a>MarKDown简单指南</h2><h4 id="1-Markdown"><a href="#1-Markdown" class="headerlink" title="1.Markdown"></a>1.Markdown</h4><p>Markdown是一种轻量级标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，并能转换成有效的 HTML 文档。<br>创始人是<strong>Aaron Swartz</strong>和<strong>John Gruber</strong>。</p>
<a id="more"></a>

<p><strong>优点</strong>  </p>
<ul>
<li><p>易读（看起来舒服）、易写（语法简单）、易更改纯文本，奉行极简主义。</p>
</li>
<li><p>跨平台使用，可以使用任何编辑器打开。</p>
</li>
<li><p>越来越多的网站支持Markdown，简书、知乎、CSDN、Github、Gitlab、Gitbook</p>
</li>
<li><p>可以导出 PDF、Word、HTML、Epub、LaTeX 等文件格式；</p>
</li>
<li><p>摆脱Word</p>
<h4 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h4><h6 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h6><p>使用=和-标记一级和二级标</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="  一级标题"></a>  一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="  二级标题"></a>  二级标题</h2><p>使用#，可表示1-6级标题</p>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h6 id="2-段落"><a href="#2-段落" class="headerlink" title="2.段落"></a>2.段落</h6><p>Markdown 语法中的段落由一行或多行文本组成的，不同的段落之间使用空行来标记。<br>如果想在段内换行，则需要在上一行的结尾插入两个以上的空格然后回车</p>
<h6 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h6><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用</p>
<blockquote>
<p>引用</p>
<blockquote>
<p>嵌套引用</p>
</blockquote>
</blockquote>
<h6 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h6><p>由三个以上的星号*或减号-或下划线_来标记</p>
<hr>
<h2 id="或"><a href="#或" class="headerlink" title="  或"></a>  或</h2><p>  或</p>
<hr>
<h6 id="5-粗体和斜体"><a href="#5-粗体和斜体" class="headerlink" title="5.粗体和斜体"></a>5.粗体和斜体</h6><p>粗体由两个*<em>或两个__包裹，斜体由一个</em>或_包裹</p>
<p>  <em>斜体</em>，<em>斜体</em><br>  <strong>粗体</strong>，<strong>粗体</strong></p>
<h6 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h6><p>无序列表由星号*或加号+或减号-标记<br>有序列表由数字和点.标记<br>嵌套列表使用制表符</p>
<h6 id="7-标记（内嵌代码）"><a href="#7-标记（内嵌代码）" class="headerlink" title="7.标记（内嵌代码）"></a>7.标记（内嵌代码）</h6><p>使用反引号</p>
<p>  <code>ctrl+a</code></p>
<h6 id="8-图片"><a href="#8-图片" class="headerlink" title="8.图片"></a>8.图片</h6><p>  <img src="%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="图片替代文字"></p>
<h6 id="9-链接"><a href="#9-链接" class="headerlink" title="9.链接"></a>9.链接</h6><p>  行内式链接<br>  <a href="链接地址" title="Title">链接文字</a><br>  参考式链接<br>  [链接文字][链接标记]<br>  [链接标记]: 链接地址  “Title”<br>  自动链接<br>  &lt;URL或邮箱地址&gt;</p>
<h6 id="10-转义"><a href="#10-转义" class="headerlink" title="10.转义"></a>10.转义</h6><p>使用 \（反斜杠）来插入一些特殊符号</p>
<h5 id="3-常用编辑器"><a href="#3-常用编辑器" class="headerlink" title="3.常用编辑器"></a>3.常用编辑器</h5></li>
</ul>
<ul>
<li>Linux<ul>
<li>VSCode</li>
<li>Ato</li>
<li>Typora</li>
<li>ReTex</li>
<li>UberWrite</li>
<li>RStudio</li>
</ul>
</li>
<li>Windows<ul>
<li>VSCod</li>
<li>Ato</li>
<li>CuteMarkE</li>
<li>MarkdownPad</li>
<li>Mi</li>
<li>Typor</li>
<li>RStudio</li>
</ul>
</li>
<li>浏览器插件<ul>
<li>MaDo (Chrome</li>
<li>Marxico（Chrome）</li>
</ul>
</li>
</ul>
<p><strong>推荐：</strong>typora</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客（一）：HEXO+Github搭建个人博客</title>
    <url>/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHEXO-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列博客主要记录使用HEXO + Github Pages搭建个人博客的过程，以及与主题设计、使用技巧、插件推荐等方面相关的内容。</p>
<a id="more"></a>

<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>1.1 注册Github</p>
<p>1.2 安装Git</p>
<p>1.3 安装Node.js</p>
<blockquote>
<p>本次搭建基于以下环境：<br>win10<br><span class="exturl" data-url="bWFpbHRvOm5vZGUuanNAMTAuMTYuMA==" title="mailto:node.js@10.16.0">node.js@10.16.0<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="bWFpbHRvOmdpdEAyLjIyLjA=" title="mailto:git@2.22.0">git@2.22.0<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="bWFpbHRvOmhleG9AMi4wLjA=" title="mailto:hexo@2.0.0">hexo@2.0.0<i class="fa fa-external-link"></i></span></p>
</blockquote>
<h2 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2.创建仓库"></a>2.创建仓库</h2><p>在github上创建名为 <code>用户名.github.io</code>的仓库，作为以后的博客地址 <code>http://用户名.github.io</code></p>
<p>注：每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库</p>
<h2 id="3-创建-HEXO-博客"><a href="#3-创建-HEXO-博客" class="headerlink" title="3. 创建 HEXO 博客"></a>3. 创建 HEXO 博客</h2><h3 id="3-1-全局安装"><a href="#3-1-全局安装" class="headerlink" title="3.1 全局安装"></a>3.1 全局安装</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<h3 id="3-2-初始化"><a href="#3-2-初始化" class="headerlink" title="3.2 初始化"></a>3.2 初始化</h3><p>​    切换到目标路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<h3 id="3-3-首次生成"><a href="#3-3-首次生成" class="headerlink" title="3.3 首次生成"></a>3.3 首次生成</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<h3 id="3-4-本地预览"><a href="#3-4-本地预览" class="headerlink" title="3.4 本地预览"></a>3.4 本地预览</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>访问： <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==" title="http://localhost:4000/">http://localhost:4000/<i class="fa fa-external-link"></i></span></p>
<h2 id="4-关联Github仓库"><a href="#4-关联Github仓库" class="headerlink" title="4. 关联Github仓库"></a>4. 关联Github仓库</h2><h3 id="4-1-配置文件"><a href="#4-1-配置文件" class="headerlink" title="4.1 配置文件"></a>4.1 配置文件</h3><p>根目录下的_config.yml文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名&#x2F;用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h3 id="4-2-安装部署插件"><a href="#4-2-安装部署插件" class="headerlink" title="4.2 安装部署插件"></a>4.2 安装部署插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="4-3-首次运行"><a href="#4-3-首次运行" class="headerlink" title="4.3 首次运行"></a>4.3 首次运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g	# 生成</span><br><span class="line">$ hexo d	# 部署</span><br></pre></td></tr></table></figure>

<p>访问：<span class="exturl" data-url="aHR0cHM6Ly9Zb3VyTmFtZS5naXRodWIuaW8v" title="https://YourName.github.io/">https://YourName.github.io/<i class="fa fa-external-link"></i></span></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客（二）：HEXO框架基本配置和使用</title>
    <url>/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AHEXO%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="个人博客（二）：HEXO框架基本配置和使用"><a href="#个人博客（二）：HEXO框架基本配置和使用" class="headerlink" title="个人博客（二）：HEXO框架基本配置和使用"></a>个人博客（二）：HEXO框架基本配置和使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅记录一些初次使用HEXO框架时的基本配置和常用命令。</p>
<p>HEXO框架的详细配置和命令可参考官方文档：</p>
<p>配置：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbg==" title="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration<i class="fa fa-external-link"></i></span></p>
<p>命令：<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29tbWFuZHM=" title="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands<i class="fa fa-external-link"></i></span></p>
<a id="more"></a>

<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>配置文件即站点根目录下的 <code>_config.yml</code> 文件允许我们对站点进行详细的设置。</p>
<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Site</td>
<td>网站的个性化描述</td>
</tr>
<tr>
<td>URL</td>
<td>博客文章 URL 的设置</td>
</tr>
<tr>
<td>Directory</td>
<td>目录设置</td>
</tr>
<tr>
<td>Writing</td>
<td>写作设置</td>
</tr>
<tr>
<td>Home page setting</td>
<td>首页设置</td>
</tr>
<tr>
<td>Category &amp; Tag</td>
<td>时间和日期的显示格式</td>
</tr>
<tr>
<td>Pagination</td>
<td>分页设置</td>
</tr>
<tr>
<td>Extensions</td>
<td>主题和插件设置</td>
</tr>
<tr>
<td>Deployment</td>
<td>网站部署的配</td>
</tr>
</tbody></table>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="hexo-init"><a href="#hexo-init" class="headerlink" title="hexo init"></a>hexo init</h3><p><strong>初始化</strong>本地文件夹为博客的根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure>

<h3 id="hexo-n"><a href="#hexo-n" class="headerlink" title="hexo n"></a>hexo n</h3><p> <strong>新建文章</strong> ，全名为 <code>hexo new</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>layout 指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定</p>
</blockquote>
<blockquote>
<p>title 指定文章标题，如果参数值中含有空格，则需要使用双引号包围</p>
</blockquote>
<h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h3><p> *<em>生成静态文件 *</em>，全名为 <code>hexo generate</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g [-d]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结合-d 表示生成后立即部署，与 <code>hexo d -g</code> 等价</p>
</blockquote>
<h3 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h3><p><strong>启动本地服务器</strong>，全名为 <code>hexo server</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s [-p&#x2F;-i&#x2F;-s]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-p    指定服务器端口，默认为 4000</p>
<p>-i     指定服务器 IP 地址，默认为 0.0.0.0 </p>
<p>-s    静态模式 ，提供 public 文件夹中的文件并禁用文件监视</p>
</blockquote>
<p><strong>注：</strong>运行本地服务器需要安装 hexo-server 插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><p><strong>部署网站</strong>，全名为<code>hexo deploy</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d [-g]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-g</code> 选项，指定生成后部署，与 <code>hexo g -d</code> 等价</li>
</ul>
<p><strong>说明</strong> ：部署前需要修改 _config.yml 配置文件，下面以 部署到 GitHub 为例进行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: 自定义提交消息，默认为Site updated: &#123;&#123; now(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h3><p><code>hexo clean</code> 命令用于 清理缓存文件和已生成的静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客（三）：HEXO博客个性化设置</title>
    <url>/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AHEXO%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="个人博客（三）：HEXO博客个性化设置"><a href="#个人博客（三）：HEXO博客个性化设置" class="headerlink" title="个人博客（三）：HEXO博客个性化设置"></a>个人博客（三）：HEXO博客个性化设置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该系列博客主要记录使用HEXO + Github Pages搭建个人博客的过程，以及与主题设计、使用技巧、插件推荐等方面相关的内容。</p>
<p>本篇是在使用博客过程中个性化的自定义设置，会持续更新并进行改动。</p>
<a id="more"></a>

<h2 id="一-更改主题"><a href="#一-更改主题" class="headerlink" title="一 更改主题"></a>一 更改主题</h2><p>自定义主题只需将主题文件拷贝到站点目录的 <code>themes</code> 文件夹下并修改配置文件，下面以安装设置Next 主题 为例。</p>
<h3 id="1-1-下载Next"><a href="#1-1-下载Next" class="headerlink" title="1.1 下载Next"></a>1.1 下载Next</h3><p>在站点根目录下用Git克隆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<h3 id="1-2-启用Next"><a href="#1-2-启用Next" class="headerlink" title="1.2 启用Next"></a>1.2 启用Next</h3><p>修改站点配置文件<code>_config.yml</code>， 将<code>theme</code> 字段的值更改为 <code>next</code></p>
<h3 id="1-3-验证"><a href="#1-3-验证" class="headerlink" title="1.3 验证"></a>1.3 验证</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo clean 	<span class="comment">//清除缓存</span></span><br><span class="line">hexo g		<span class="comment">//生成文件</span></span><br><span class="line">hexo s		<span class="comment">//运行本地服务</span></span><br></pre></td></tr></table></figure>

<p>访问 <code>http://localhost:4000</code>，检查站点是否正确运行</p>
<h3 id="1-4-更新主题"><a href="#1-4-更新主题" class="headerlink" title="1.4 更新主题"></a>1.4 更新主题</h3><p>在主题目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h2 id="二博客站点配置"><a href="#二博客站点配置" class="headerlink" title="二博客站点配置"></a>二博客站点配置</h2><p>修改站点配置文件<code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="comment">#网站的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span> <span class="comment">#网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">''</span> <span class="comment">#网站描述</span></span><br><span class="line"><span class="attr">keywords:</span>  <span class="comment">#网站关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="comment">#网站作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#语言 zh-CN简体中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span> <span class="comment">#时区，默认就好</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span>  <span class="comment">#网站地址 比如：https://yourname.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span> <span class="comment">#网站根目录</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:category/:title/</span>	<span class="comment">#网站的url格式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自动提交到仓库，可以设置多个仓库</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line">    <span class="attr">Gitee:</span> <span class="string">https://gitee.com/yourname/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h2 id="三-Next主题配置"><a href="#三-Next主题配置" class="headerlink" title="三 Next主题配置"></a>三 Next主题配置</h2><p>详细设置请参考Next主题的官方说明</p>
<p>Next：<span class="exturl" data-url="aHR0cDovL3RoZW1lLW5leHQuaWlzc25hbi5jb20vZ2V0dGluZy1zdGFydGVkLmh0bWw=" title="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html<i class="fa fa-external-link"></i></span></p>
<p>以下为Next主题常用的自定义设置，只需修改主题目录下的配置文件<code>_config.yml</code></p>
<h3 id="3-1-选择外观风格"><a href="#3-1-选择外观风格" class="headerlink" title="3.1 选择外观风格"></a>3.1 选择外观风格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="3-2-语言设置"><a href="#3-2-语言设置" class="headerlink" title="3.2 语言设置"></a>3.2 语言设置</h3><p>支持的语言可通过 languages 文件夹查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN	&#x2F;&#x2F;简体中文</span><br></pre></td></tr></table></figure>

<h3 id="3-3-菜单设置"><a href="#3-3-菜单设置" class="headerlink" title="3.3 菜单设置"></a>3.3 菜单设置</h3><p>（1）菜单项的文本显示</p>
<p>修改 themes/next/languages/zh-Hans.yml 文件的 menu 字段对应的中文或者新增。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">日程表</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">站点地图</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">公益</span> <span class="number">404</span></span><br><span class="line">  <span class="comment"># 新增menu</span></span><br><span class="line">  <span class="attr">catalogue:</span> <span class="string">目录</span></span><br></pre></td></tr></table></figure>

<p>（2）菜单项的图标设置</p>
<p>主题配置文件<code>_config.yml</code>的<code>menu</code>字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br><span class="line"></span><br><span class="line"># Enable &#x2F; Disable menu icons &#x2F; item badges.</span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: false</span><br><span class="line"> &#x2F;&#x2F;这个名称并不直接显示在页面上，而是用于匹配图标以及翻译</span><br></pre></td></tr></table></figure>

<p>（3）创建菜单项对应的页面</p>
<p>除了 <code>home</code>， <code>archives</code> ,其他页面都要手动创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#分类</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">#标签</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">#关于</span><br><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>

<p>对应的文件夹会被创建于<code>source</code> 目录下，在里面的 <code>index.md</code> 文件添加描述，如categories</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories </span><br><span class="line">date: 2020-03-20 10:32:05</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="3-4-头像设置"><a href="#3-4-头像设置" class="headerlink" title="3.4 头像设置"></a>3.4 头像设置</h3><p>将 <code>avatar</code> 的值设置成头像图片的链接地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: #&#x2F;images&#x2F;avatar.gif</span><br><span class="line">  # 修改头像边框为圆形</span><br><span class="line">  rounded: true</span><br><span class="line">  # 鼠标放置头像时，头像旋转特效</span><br><span class="line">  rotated: true</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>廖雪峰Git教程学习笔记</title>
    <url>/uncategorized/%E5%BB%96%E9%9B%AA%E5%B3%B0Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="廖雪峰Git教程学习笔记"><a href="#廖雪峰Git教程学习笔记" class="headerlink" title="廖雪峰Git教程学习笔记"></a>廖雪峰Git教程学习笔记</h1><h2 id="一-Git简介"><a href="#一-Git简介" class="headerlink" title="一.Git简介"></a>一.Git简介</h2><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br><strong>版本控制系统</strong>：自动记录跟踪每次文件的改动，作一个文件快照，形成一个版本。<br>分布式版本控制系统：每个人电脑里都有完整的版本库，不必联网，中央服务器主要用于交换团队的修改。</p>
<a id="more"></a>

<blockquote>
<p>Mercurial、Bazaar、BitKeeper、Git</p>
</blockquote>
<p>集中式的版本控制系统：版本库集中存放在中央服务器，必须联网才能工作。</p>
<blockquote>
<p>CVS、SVN</p>
</blockquote>
<p>历史：linux之父为了更好的管理他自己的开源项目linux系统而自己用C语言开发的分布式版本控制系统Git</p>
<h2 id="二-Git安装"><a href="#二-Git安装" class="headerlink" title="二.Git安装"></a>二.Git安装</h2><h3 id="2-1-Linux上安装"><a href="#2-1-Linux上安装" class="headerlink" title="2.1 Linux上安装"></a>2.1 Linux上安装</h3><p>1.判断是否已安装Git</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git</span><br></pre></td></tr></table></figure>

<p>2.否则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-core（旧）</span><br></pre></td></tr></table></figure>

<p>3.其他：<br>从Git官网下载源码，解压，依次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;config</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Windows上安装Git"><a href="#2-2-Windows上安装Git" class="headerlink" title="2.2 Windows上安装Git"></a>2.2 Windows上安装Git</h3><p>1.从Git官网下载安装程序,直接安装（或<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ2l0LWluc3RhbGxlci9naXQtZm9yLXdpbmRvd3PvvIk=" title="https://gitee.com/git-installer/git-for-windows）">https://gitee.com/git-installer/git-for-windows）<i class="fa fa-external-link"></i></span><br>2.配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span><span class="comment">//名字</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span><span class="comment">//邮箱</span></span><br></pre></td></tr></table></figure>

<h2 id="三-创建版本库"><a href="#三-创建版本库" class="headerlink" title="三.创建版本库"></a>三.创建版本库</h2><p>仓库/repository/仓库/目录</p>
<p>1.选择一个合适的地方，创建一个空目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit	<span class="comment">//创建一个空文件夹</span></span><br><span class="line"></span><br><span class="line">$ cd learngit	<span class="comment">//移动到新文件夹</span></span><br><span class="line"></span><br><span class="line">$ pwd	<span class="comment">//显示当前位置的路径</span></span><br></pre></td></tr></table></figure>

<p>2.初始化目录，将其变成Git可以管理的仓库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git init	<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">$ git ls -ah 	<span class="comment">//罗列目录下的文件</span></span><br></pre></td></tr></table></figure>

<p>成功会自动创建.git文件夹，Git用来跟踪管理版本库</p>
<p>所有的版本控制系统只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等</p>
<p>无法跟踪图片、视频、Word等二进制文件的变化</p>
<p>Windows自带记事本的文本文件开头有个0xefbbbf，可能编译错误，不推荐</p>
<h2 id="四-添加提交修改"><a href="#四-添加提交修改" class="headerlink" title="四.添加提交修改"></a>四.添加提交修改</h2><h3 id="4-1-把文件添加到仓库"><a href="#4-1-把文件添加到仓库" class="headerlink" title="4.1 把文件添加到仓库"></a>4.1 把文件添加到仓库</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git add file	<span class="comment">//反复多次使用，添加多个文件，把文件修改添加到暂存区</span></span><br><span class="line">$ git add *	<span class="comment">//将所有更改一次性添加</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-把文件提交到仓库"><a href="#4-2-把文件提交到仓库" class="headerlink" title="4.2 把文件提交到仓库"></a>4.2 把文件提交到仓库</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"description"</span>	<span class="comment">//一次提交，把暂存区的所有内容提交到当前分支</span></span><br></pre></td></tr></table></figure>

<h2 id="五-版本控制"><a href="#五-版本控制" class="headerlink" title="五.版本控制"></a>五.版本控制</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>工作区（Working Directory）：存在文件的目录<br>版本库（Repository）：.git文件夹<br>暂存区（stage或index）：<br>分支（branch）：<br>master分支：Git自动创建的唯一一个主分支<br>commit id：版本号<br>HEAD：表示当前版本 HEAD^：上一个版本 HEAD^^：上上一个版本 ……  HEAD~100：上100个版本<br>$ git status    //查看仓库当前的状态<br>$ git diff file    //查看已修改未提交内容与最新版本的不同</p>
<h3 id="5-2-版本回退"><a href="#5-2-版本回退" class="headerlink" title="5.2 版本回退"></a>5.2 版本回退</h3><p>$ git log或$ git log –pretty=oneline    //显示从最近到最远的提交日志<br>$ git reset –hard HEAD^    //回退到上一个版本<br>$ git reset –hard 1094a    //回到1094adb…版本<br>$ git reflog    //查看命令日志<br>原理：Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向该版本号并更新工作区的文件</p>
<h3 id="5-3-管理修改"><a href="#5-3-管理修改" class="headerlink" title="5.3 管理修改"></a>5.3 管理修改</h3><p>每次修改，如果不用git add到暂存区，那就不会加入到commit中。<br>git diff HEAD – file    //查看工作区和版本库里面最新版本的区别.</p>
<h3 id="5-4-撤销修改"><a href="#5-4-撤销修改" class="headerlink" title="5.4 撤销修改"></a>5.4 撤销修改</h3><p>人工修改<br>$ git checkout – file    //丢弃工作区的修改<br>$ git reset HEAD <file>    //撤销暂存区的修改<br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，不过前提是没有推送到远程库。</p>
<h3 id="5-5-删除文件"><a href="#5-5-删除文件" class="headerlink" title="5.5 删除文件"></a>5.5 删除文件</h3><p>$ rm file    //删除文件管理器的文件<br>$ git rm file    //从版本库中删除文件<br>$ git checkout – file。//恢复错删文件</p>
<h2 id="六-远程仓库"><a href="#六-远程仓库" class="headerlink" title="六.远程仓库"></a>六.远程仓库</h2><p>Github–&gt;Git远程仓库</p>
<h3 id="6-1-配置SSH"><a href="#6-1-配置SSH" class="headerlink" title="6.1 配置SSH"></a>6.1 配置SSH</h3><p>1 检查是否存在SSH Key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ls	&#x2F;&#x2F;看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key</span><br></pre></td></tr></table></figure>

<p>2 创建SSH Key</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure>

<p>3 关联Github</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ cat id_rsa.pub	<span class="comment">//查看密钥并复制</span></span><br></pre></td></tr></table></figure>

<p>登陆GitHub，打开“Account settings”，“SSH Keys”页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</p>
<p>4 成功验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line"><span class="comment">//运行结果出现如下提示</span></span><br><span class="line">Hi xiangshuo1992! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-关联远程库"><a href="#6-2-关联远程库" class="headerlink" title="6.2 关联远程库"></a>6.2 关联远程库</h3><p>1.Github上创建repository</p>
<p>2.本地仓库关联github的远程库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:用户名/远程仓库名.git</span><br></pre></td></tr></table></figure>

<p>3.把本地仓库的内容推送到GitHub仓库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>

<p>4.推送最新修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<h3 id="6-3-克隆远程库"><a href="#6-3-克隆远程库" class="headerlink" title="6.3 克隆远程库"></a>6.3 克隆远程库</h3><p>1.确定Github上repository的地址</p>
<p>2.克隆远程库到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:用户名&#x2F;仓库名.git</span><br></pre></td></tr></table></figure>

<h2 id="七-分支管理"><a href="#七-分支管理" class="headerlink" title="七.分支管理"></a>七.分支管理</h2><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。</p>
<p>一开始，只有一条时间线，在Git里，这个分支叫主分支，即master分支。</p>
<p>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就</p>
<p>能确定当前分支，以及当前分支的提交点：</p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把</p>
<p>HEAD指向dev，就表示当前分支在dev上：</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变</p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，</p>
<p>就是直接把master指向dev的当前提交，就完成了合并</p>
<h3 id="7-1-创建与合并分支"><a href="#7-1-创建与合并分支" class="headerlink" title="7.1 创建与合并分支"></a>7.1 创建与合并分支</h3><p>1.创建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch dev	&#x2F;&#x2F;创建分支</span><br><span class="line">$ git checkout dev	&#x2F;&#x2F;切换分支</span><br><span class="line">$ git branch	&#x2F;&#x2F;查看分支</span><br></pre></td></tr></table></figure>

<p>2.修改文件后切换回master分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>

<p>3.把dev分支的工作成果合并到master分支上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>

<p>4.删除dev分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure>

<h3 id="7-2-解决分支冲突"><a href="#7-2-解决分支冲突" class="headerlink" title="7.2 解决分支冲突"></a>7.2 解决分支冲突</h3><p>分支冲突：要合并的分支在同一提交点上有不同的修改<br>解决方法：把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>$ git status    //可查看冲突文件<br>$ git log –graph –pretty=oneline –abbrev-commit //查看分支合并图</p>
<p>分支管理策略<br>$ git merge –no-ff -m “merge with no-ff” dev<br>//强制禁用Fast forward模式，，Git就会在merge时生成一个新的commit，从分支历史上就可以看出分支信息</p>
<h3 id="7-3-分支管理策略"><a href="#7-3-分支管理策略" class="headerlink" title="7.3 分支管理策略"></a>7.3 分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下–no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：</p>
<p>$ git checkout -b dev<br>Switched to a new branch ‘dev’<br>修改readme.txt文件，并提交一个新的commit：</p>
<p>$ git add readme.txt<br>$ git commit -m “add merge”<br>[dev f52c633] add merge<br> 1 file changed, 1 insertion(+)<br>现在，我们切换回master：</p>
<p>$ git checkout master<br>Switched to branch ‘master’<br>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：</p>
<p>$ git merge –no-ff -m “merge with no-ff” dev<br>Merge made by the ‘recursive’ strategy.<br> readme.txt | 1 +<br> 1 file changed, 1 insertion(+)<br>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p>
<p>合并后，我们用git log看看分支历史：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|&#x2F;  </span><br><span class="line"></span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，不使用Fast forward模式，merge后就像这样：</p>
<p>git-no-ff-mode</p>
<h3 id="7-4-分支策略"><a href="#7-4-分支策略" class="headerlink" title="7.4 分支策略"></a>7.4 分支策略</h3><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>干活都在dev分支上，也就是说，dev分支是不稳定的。<br>到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本<br>团队每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并</p>
<p>BUG分支<br>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除<br>$ git stash        //把当前工作现场“储藏”起来，等以后恢复现场后继续工作<br>或<br>$ git stash apply stash@{0}        //恢复指定的stash<br>$ git stash list    //查看已存放的工作现场</p>
<p>$ git stash apply    //恢复工作现场<br>$ git stash drop    //删除stash内容<br>或<br>$ git stash pop        //恢复并删除stash内容</p>
<p>Feature分支<br>开发一个新feature，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除</p>
<p>多人协作<br>$ git remote    //查看远程库的信息<br>$ git remote -v        //示更远程库详细的信息</p>
<p>推送分支<br>把某分支上的所有本地提交推送到远程库。<br>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<br>$ git push origin master<br>推送原则：<br>master分支是主分支，因此要时刻与远程同步；</p>
<p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>抓取分支<br>$ git clone <span class="exturl" data-url="bWFpbHRvOmdpdEBnaXRodWIuY29t" title="mailto:git@github.com">git@github.com<i class="fa fa-external-link"></i></span>:michaelliao/learngit.git    //克隆，只有master分支<br>$ git checkout -b dev origin/dev    //创建与远程origin的相应的分支<br>当其他人已推送的的最新提交和你试图推送的提交有冲突，往往推送失败<br>解决方法：先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送<br>$ git branch –set-upstream-to=origin/dev dev    //指定本地dev分支与远程origin/dev分支的链接<br>$ git pull    //抓取分支</p>
<p>多人协作流程：<br>查看远程库信息，使用git remote -v；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p>
<p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<p>Rebase<br>把分叉的提交历史“整理”成一条直线，看上去更直观，但本地的分叉提交已经被修改过了<br>$ git rebase    //把本地未push的分叉提交历史整理成直线</p>
<h2 id="八-标签管理"><a href="#八-标签管理" class="headerlink" title="八.标签管理"></a>八.标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），<br>这样，就唯一确定了打标签时刻的版本。<br>将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。<br>所以，标签也是版本库的一个快照，实质上也是指向某个commit的指针，但不能移动</p>
<p>创建标签<br>切换到需要打标签的分支，敲命令git tag <name>就可以打一个新标签<br>$ git tag    //查看所有标签，按字母排序的<br>$ git tag v0.9 f52c633    //给指定commit id打标签<br>$ git tag -a v0.1 -m “version 0.1 released” 1094adb        //创建带有说明的标签<br>$ git show <tagname>    //查看标签信息</p>
<p>操作标签<br>$ git tag -d v0.1    //删除本地标签<br>git push origin <tagname>    //推送某个标签到远程<br>$ git push origin –tags    //一次性推送全部尚未推送到远程的本地标签</p>
<p>$ git tag -d v0.9<br>$ git push origin :refs/tags/v0.9    //删除远程标签</p>
]]></content>
  </entry>
  <entry>
    <title>jQuery笔记</title>
    <url>/%E7%AC%94%E8%AE%B0/jQuery%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="jQuery笔记"><a href="#jQuery笔记" class="headerlink" title="jQuery笔记"></a>jQuery笔记</h1><h1 id="一、初识jQuery"><a href="#一、初识jQuery" class="headerlink" title="一、初识jQuery"></a>一、初识jQuery</h1><p><strong>简介：</strong>jQuery是一个JS库，封装多种预定义的对象和函数，目的在于简化JS开发人员遍历HTML文档，操作DOM，执行动画和开发Ajax的操作,可兼容不同平台。</p>
<p><strong>本质：</strong>jQuery库就是一个叫jQuery的函数，该函数及其原型中定义了大量的方法，我们使用的就是该函数的方法。</p>
<p><strong>理念：</strong>write less,do more.</p>
<a id="more"></a>

<p><strong>其它js库：</strong>Prototype、Do jo、YUI、Ext JS、 Moo Tools</p>
<p><strong>使用：</strong>下载后在HTML内引入</p>
<script src="jquery-1.12.4/jquery-1.12.4.min.js"></script>
<p><strong>例子 Hello World:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;html&gt;</span><br><span class="line">       &lt;head&gt;</span><br><span class="line">       &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">       &lt;title&gt;dom操作&lt;&#x2F;title&gt;</span><br><span class="line">       &lt;script src&#x3D;&quot;jquery-3.3.1&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">       &lt;script&gt;</span><br><span class="line">          $(function()&#123;</span><br><span class="line">             alert(&#39;Hello World&#39;);</span><br><span class="line">          &#125;);</span><br><span class="line">       &lt;&#x2F;script&gt;</span><br><span class="line">       &lt;&#x2F;head&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="jQuery的基本概念和操作"><a href="#jQuery的基本概念和操作" class="headerlink" title="jQuery的基本概念和操作"></a>jQuery的基本概念和操作</h1><h2 id="1-jQuery的加载模式"><a href="#1-jQuery的加载模式" class="headerlink" title="1.jQuery的加载模式"></a>1.jQuery的加载模式</h2><p>js中的代码要等所有DOM元素和图片加载完成后才执行，而jQuery在所有DOM元素加载完就执行不用等待其它资源加载完成。</p>
<p>原生JS如果编写了多个入口函数,后面编写的会覆盖前面的<br>jQuery中编写多个入口函数,后面的不会覆盖前面的</p>
<h3 id="2-jQuey的入口函数及其不同写法"><a href="#2-jQuey的入口函数及其不同写法" class="headerlink" title="2.jQuey的入口函数及其不同写法"></a>2.jQuey的入口函数及其不同写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第1种写法：</span><br><span class="line">   $(document).ready(function () &#123;</span><br><span class="line">       alert(&quot;hello jquery1&quot;)</span><br><span class="line">   &#125;)</span><br><span class="line">   &#x2F;&#x2F; 第2种写法：</span><br><span class="line">   jQuery(document).ready(function () &#123;</span><br><span class="line">       alert(&quot;hello jquery2&quot;)</span><br><span class="line">   &#125;)</span><br><span class="line">   &#x2F;&#x2F; 第3种写法：（推荐）</span><br><span class="line">   $(function () &#123;</span><br><span class="line">       alert(&quot;hello jquery3&quot;)</span><br><span class="line">   &#125;)</span><br><span class="line">   &#x2F;&#x2F; 第4种写法：</span><br><span class="line">   jQuery(function () &#123;</span><br><span class="line">       alert(&quot;hello jquery4&quot;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-访问标识符-的冲突问题"><a href="#3-访问标识符-的冲突问题" class="headerlink" title="3.访问标识符$的冲突问题"></a>3.访问标识符$的冲突问题</h3><p>jQuery使用$符号来作为选择器，如果其他的框架也通用使用$符号来作为选择器，两者产生冲突，后面引入的框架会覆盖掉前面的</p>
<p>解决方案：</p>
<p>释放$的使用权，释放之后就不能再使用$,改为使用jQuey　　　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.noConflict();</span><br></pre></td></tr></table></figure>

<p>可自定义一个访问符号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var jn &#x3D; jQuery.noConflict();</span><br></pre></td></tr></table></figure>

<h3 id="4-核心函数及其可接受的参数"><a href="#4-核心函数及其可接受的参数" class="headerlink" title="4.核心函数及其可接受的参数"></a>4.核心函数及其可接受的参数</h3><p><strong>核心函数：</strong>$();</p>
<p><strong>四种参数：</strong></p>
<p><strong>1）字符串选择器</strong><br>jQuery函数通过该选择器获取对应的DOM，然后将这些DOM封装成一个jQuery对象中并返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var $box &#x3D; $(&quot;.box&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>2）DOM元素</strong><br>jQuery函数将该DOM元素封装成jQuery对象并返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var span &#x3D; document.genElementsByTagName(&quot;span&quot;)[0];</span><br><span class="line"></span><br><span class="line">var $span &#x3D; $(span);</span><br></pre></td></tr></table></figure>

<p><strong>3）HTML文本字符串</strong><br>jQuery函数根据传入的文本创建好HTML元素并封装成jQuery对象返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var $one &#x3D; $(&quot;&lt;div class&#x3D;&quot;one&quot;&gt;one&lt;&#x2F;div&gt;&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>4）匿名函数</strong></p>
<p>当文档加载完毕之后jQuery函数调用匿名函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-jQuery对象"><a href="#5-jQuery对象" class="headerlink" title="5.    jQuery对象"></a>5.    jQuery对象</h3><p>jQuery对象是jQuery函数的一个实例，是一个类数组对象(伪数组，具有索引-值形式和length属性），数组中存放的是DOM对象，而DOM对象是Node的实例。</p>
<p>对jQuery对象的操作实际上是对jQuery数组中的DOM对象的批量操作。jQuery对象和DOM对象可以相互转化。</p>
<p> jQuery对象的获取通常是使用选择器来获取的。比如，获取所有clss为one元素:$(“.one”);</p>
<h3 id="6-jQuery选择器"><a href="#6-jQuery选择器" class="headerlink" title="6.    jQuery选择器"></a>6.    jQuery选择器</h3><p><strong>基本选择器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有选择器  *</span><br><span class="line">标签选择器  标签名</span><br><span class="line">ID选择器    #id</span><br><span class="line">类选择器    .className</span><br><span class="line">群组选择器  .one,.two   多个选择器使用**,**分隔，取并集</span><br><span class="line">复合选择器  .one.two   多个选择器组合使用，取交集</span><br></pre></td></tr></table></figure>

<p><strong>层次选择器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后代选择器   .one .two   </span><br><span class="line">  两个选择器使用空格隔开，表示可以获取当前元素的子代以及孙子代等等后代元素。</span><br><span class="line">子代选择器   .one&gt;.two</span><br><span class="line">  两个选择器使用&gt;隔开，表示只能获取当前选中元素的子代元素。</span><br></pre></td></tr></table></figure>

<p><strong>兄弟选择器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下一个兄弟选择器   .one+.two</span><br><span class="line">   两个选择器使用+隔开，表示可以获取当前元素的下一个兄弟元素，下一个兄弟元素要能符合.two</span><br><span class="line">之后所有子代选择器  .one~.two</span><br><span class="line">   两个选择器使用~隔开，表示可以获取当前元素之后的所有兄弟元素，只有所有兄弟元素要能符合.two</span><br></pre></td></tr></table></figure>

<h3 id="7-jQuery过滤器"><a href="#7-jQuery过滤器" class="headerlink" title="7.jQuery过滤器"></a>7.jQuery过滤器</h3><p>jQuery的过滤器必须用在jQuery选择器后，表示对通过前面的jQuery选择器选择到的内容的过滤，建立在前面选择器已经选择到的元素的基础之上。 </p>
<p>语法：selector:过滤器</p>
<p><strong>基本过滤器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector:first  获取所有已选择到的元素中的第一个元素</span><br><span class="line">selector:last   获取所有已选择到的元素中的最后一个元素</span><br><span class="line">selector:even    获取所有已选择到的元素中的索引为偶数的元素</span><br><span class="line">selector:odd     获取所有已选择到的元素中的索引为奇数的元素</span><br><span class="line">selector:eq(index) 获取所有已选择到的元素中的索引为index的元素</span><br><span class="line">selector:lt(num)   获取所有已选择到的元素中的索引值小于num的元素</span><br><span class="line">selector:gt(num)   获取所有已选择到的元素中的索引值大于num的元素</span><br><span class="line">selector1:not(selector2)  获取所有已选择到的元素中的除了selector2的元素</span><br><span class="line">selector:header   获取所有已选择到的元素中的标题元素(h1~h6)</span><br></pre></td></tr></table></figure>

<p><strong>内容过滤器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector:contains(text) </span><br><span class="line">          获取所有已选择到的元素中包含指定文本text的元素</span><br><span class="line">selector:empty   </span><br><span class="line">          获取所有已选择到的元素中的空元素(没有子节点和文本)</span><br><span class="line">selector:parent  </span><br><span class="line">          获取所有已选择到的元素中的非空元素(有子节点或文本)，如$(&quot;div:parent&quot;);</span><br><span class="line">selector1:has(selector2)  </span><br><span class="line">          获取所有已选择到的元素中包含selector2的元素，如$(&quot;div:has(&#39;span&#39;)&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>可见性过滤器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">隐藏类型分两种：</span><br><span class="line"></span><br><span class="line">  1）不占据屏幕空间</span><br><span class="line">        display:none;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot;&gt;	</span><br><span class="line">  2）占据屏幕空间</span><br><span class="line">        visibility:hidden;</span><br><span class="line">        opacity:0;&#x2F;&#x2F;透明度为0</span><br><span class="line">   使用：</span><br><span class="line">      :visible   选择所有占据屏幕空间的元素</span><br><span class="line">      :hidden    选择所有不占据屏幕空间的元素</span><br></pre></td></tr></table></figure>

<p><strong>属性过滤器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector[attrKey]  </span><br><span class="line">         获取所有已选择到的元素中具有属性attrKey的元素</span><br><span class="line"> selector[attrKey&#x3D;attrVal]    </span><br><span class="line">         获取所有已选择到的元素中具有属性attrKey，并且属性值为attrVal的元素</span><br><span class="line"> selector[attrKey^&#x3D;attrVal]  </span><br><span class="line">         获取所有已选择到的元素中具有属性attrKey，并且属性值为以attrVal开头的元素</span><br><span class="line"> selector[attrKey$&#x3D;attrVal]  </span><br><span class="line">         获取所有已选择到的元素中具有属性attrKey，并且属性值为以attrVal结尾的元素</span><br><span class="line"> selector[attrKey*&#x3D;attrVal]  </span><br><span class="line">         获取所有已选择到的元素中具有属性attrKey，并且属性值为包含attrVal的元素</span><br><span class="line"> selector[attrKey!&#x3D;attrVal]  </span><br><span class="line">         获取所有已选择到的元素中具有属性attrKey，并且属性值不为以attrVal的元素或者没有属性attrVal的元素</span><br></pre></td></tr></table></figure>

<p><strong>后代选择器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector:nth-child(index)</span><br><span class="line">      获取每个selector元素中索引为index的子元素。【注意】index从1开始</span><br><span class="line">  selector:first-child</span><br><span class="line">      获取每一个selector元素中的第一个子元素（每个父元素的第一个子元素）</span><br><span class="line">  selector:last-child</span><br><span class="line">      获取每一个selector元素中的最后一个子元素（每个父元素的最后一个子元素）</span><br><span class="line">  selector:only-child</span><br><span class="line">      获取每一个selector元素中的独生子子元素（每个父元素如果只有一个孩子元素，获取该元素）</span><br><span class="line">  selector:first-of-type</span><br><span class="line">      获取每个selector元素中每种类型子元素中的第一个</span><br><span class="line">  selector:last-of-type</span><br><span class="line">      获取每个selector元素中每种类型子元素中的最后一个</span><br></pre></td></tr></table></figure>

<p><strong>表单过滤器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:checked    选取所有被选中的元素，用于复选框、单选框、下拉框</span><br><span class="line">  :selected   选取所有被选中的元素，该选择器只适用于&lt;option&gt;</span><br><span class="line">  :focus   选取当前获取焦点的元素</span><br><span class="line">  :text    选取所有的单行文本框(&lt;input type&#x3D;&quot;text&quot;&gt;)</span><br><span class="line">  :password  选取所有的密码框</span><br><span class="line">  :input     选取所有的&lt;input&gt;,&lt;textarea&gt;,&lt;select&gt;,&lt;button&gt;元素。</span><br><span class="line">    *注意，$(&quot;:input&quot;)是选中可以让用户输入的标签元素；而$(&quot;input&quot;)是选择名字为input的标签元素。*</span><br><span class="line">  :enable   选取所有可用元素，该选择器仅可用于支持disable属性的html元素。(&lt;button&gt;,&lt;input&gt;,&lt;optgruop&gt;,&lt;option&gt;,&lt;select&gt;,&lt;textarea&gt;)</span><br><span class="line">  :disable   选取所有不可用元素，该选择器也仅可用于支持disable属性的html元素。</span><br><span class="line">  :radio      选取所有的单选框</span><br><span class="line">  :checkbox   选取所有的多选框</span><br><span class="line">  :submit     选取所有的提交按钮</span><br><span class="line">  :image      选取所有的input类型为image的表单元素</span><br><span class="line">  :reset   选取所有的input类型为reset的表单元素</span><br><span class="line">  :button  选取所有的input类型为button的表单元素</span><br><span class="line">  :file    选取所有的input类型为file的表单元素</span><br></pre></td></tr></table></figure>

<h3 id="8-jQuery中的Dom操作"><a href="#8-jQuery中的Dom操作" class="headerlink" title="8.jQuery中的Dom操作"></a>8.jQuery中的Dom操作</h3><h4 id="8-1-查找节点"><a href="#8-1-查找节点" class="headerlink" title="8.1 查找节点"></a><strong>8.1 查找节点</strong></h4><p>通过jQuery选择器来完成</p>
<h4 id="8-2-创建节点"><a href="#8-2-创建节点" class="headerlink" title="8.2 创建节点"></a><strong>8.2 创建节点</strong></h4><p>  创建元素节点：var newTd = $(“<td></td>“)<br>  创建文本节点：var newTd = $(“<td>文本内容</td>“)</p>
<h4 id="8-3-插入节点"><a href="#8-3-插入节点" class="headerlink" title="8.3 插入节点"></a><strong>8.3 插入节点</strong></h4><p> <strong>8.3.1 内部插入</strong></p>
<p>  1) $A.<strong>append</strong>(B)<br>       将B追加到A的末尾处，作为它的最后一个子元素</p>
<pre><code>$A.**appendTo**(B)
 将A追加到B的末尾，作为它的最后一个子元素</code></pre><p>  2)  $A.<strong>prepend</strong>(B)<br>       将B追加到A的前面，作为它的第一个子元素</p>
<p>​       $A.<strong>prependTo</strong>(B)<br>​        将A追加到B的前面，作为它的第一个子元素</p>
<p> <strong>8.3.2 外部插入</strong></p>
<p>  1) $A.<strong>after</strong>(B)<br>            在A之后追加B，作为它的兄弟元素<br>       $A.<strong>insertAfter</strong>(B)<br>            在B之后追加A，作为它的兄弟元素<br>   2) $A.<strong>before</strong>(B)<br>            在A之前追加B，作为它的兄弟元素<br>       $A.<strong>insertBefore</strong>(B)<br>             在B之前追加A，作为它的兄弟元素</p>
<h4 id="8-4-删除节点"><a href="#8-4-删除节点" class="headerlink" title="8.4 删除节点"></a><strong>8.4 删除节点</strong></h4><p>   <strong>remove</strong>([selector])<br>       从DOM中删除所有匹配的元素，返回值是一个指向已经被删除的节点的引用，可以在以后再使用这些元素。<br>       该方法会移除元素，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。<br>   <strong>detach</strong>([selector])<br>       与remove()类似，但是detach()保存所有jQuery数据和被移走的元素的相关联事件。<br>   <strong>empty</strong>()<br>       无参数。从DOM中清空集合中匹配元素的所有的子节点。</p>
<h4 id="8-5-复制节点"><a href="#8-5-复制节点" class="headerlink" title="8.5 复制节点"></a><strong>8.5 复制节点</strong></h4><p> $(“#id”).<strong>clone</strong>(false|true);<br>  该方法返回的是一个节点的引用</p>
<p>  参数默认为false，为浅复制，只复制元素不复制事件；<br>  参数是true时,为深复制，复制元素的同时复制元素中所绑定的事件。</p>
<h4 id="8-6-替换节点"><a href="#8-6-替换节点" class="headerlink" title="8.6 替换节点"></a><strong>8.6 替换节点</strong></h4><p>   <strong>replaceWith</strong>(newContent);<br>        用新内容替换集合中所有匹配的元素，并且返回被删除的元素的集合。<br>        该方法会删除与节点相关联的所有数据和事件处理程序。<br>   <strong>replaceAll</strong>(target);<br>        用集合的匹配元素替换每个目标元素。</p>
<h4 id="8-7-包裹节点"><a href="#8-7-包裹节点" class="headerlink" title="8.7 包裹节点"></a><strong>8.7 包裹节点</strong></h4><p>   wrap([wrappingElement])<br>        在每个匹配的元素外层包上一个html元素<br>   warpAll([wrappingElement])<br>        将所有匹配的元素用一个元素来包裹，在所有匹配元素外面包裹一层HTML结构<br>   warpInner([wrappingElement])<br>        每个匹配元素里面内容(子元素)都会被这种结构包裹</p>
<h4 id="8-8-节点遍历"><a href="#8-8-节点遍历" class="headerlink" title="8.8 节点遍历"></a><strong>8.8 节点遍历</strong></h4><p>   children([selector])<br>        用于取得匹配元素的子元素集合(只考虑子元素而不考虑任何后代元素)<br>      $(‘.content.inner’)=&gt;$(‘.content’).children(‘.inner’);<br>   find(selector)<br>        在当前对象元素中的子元素查找，和参数所匹配的所有的后代元素<br>   next([selector])<br>        取得匹配的元素集合中每一个元素紧邻的后面兄弟元素<br>   nextAll([selector])<br>        查找当前元素之后所有的同辈元素<br>   prev([selector])<br>         取得匹配元素前面紧邻的兄弟元素<br>   prevAll([selector])<br>         取得当前元素之前所有的同辈元素<br>   silibinng([selector])<br>         取得匹配元素的前后所有的兄弟元素<br>   closest(selector)<br>         取得和参数匹配的最近的元素，如果匹配不上继续向上查找父元素<br>   filter(selector)<br>         把当前所选择的所有元素再进行筛选过滤<br>   parent([selector])<br>         取得匹配元素的集合中，每个元素的父元素<br>   parents([selector])<br>         获得集合中每个匹配元素的祖先元素</p>
<h1 id="二、jQuery的API和事件"><a href="#二、jQuery的API和事件" class="headerlink" title="二、jQuery的API和事件"></a>二、jQuery的API和事件</h1><h2 id="1-静态方法和实例方法"><a href="#1-静态方法和实例方法" class="headerlink" title="1.    静态方法和实例方法"></a>1.    静态方法和实例方法</h2><p>静态方法：在类上添加的方法，通过类名调用</p>
<p>实例方法：在类的原型上添加的方法，通过类的实例调用</p>
<h2 id="2-静态方法-通过-调用"><a href="#2-静态方法-通过-调用" class="headerlink" title="2.    静态方法(通过$调用)"></a>2.    静态方法(通过$调用)</h2><h4 id="2-1-each"><a href="#2-1-each" class="headerlink" title="2.1 each()"></a>2.1 each()</h4><p>可遍历数组或伪数组（jQuery对象)，默认返回在遍历的数组，不支持在回调函数中对数组进行处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.each(arr,function(index,value)&#123;</span><br><span class="line">&#x2F;&#x2F;第一个参数为遍历元素的索引</span><br><span class="line">&#x2F;&#x2F;第二个参数为遍历的元素</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>原生JS的foreach()，只能遍历数组（伪数组也不行）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.foreach(function(value,index)&#123;</span><br><span class="line">&#x2F;&#x2F;第一个参数为遍历的元素</span><br><span class="line">&#x2F;&#x2F;第二个参数为当前元素的索引</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-map"><a href="#2-2-map" class="headerlink" title="2.2 map()"></a>2.2 map()</h4><p>通过$调用，可遍历数组或伪数组（jQuery对象)，默认返回空数组，可生成新数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.map(arr,function(value,index)&#123;</span><br><span class="line">&#x2F;&#x2F;第一个参数为要遍历的数组</span><br><span class="line">&#x2F;&#x2F;第二个参数为每遍历一个元素执行的回调函数</span><br><span class="line">return value+index；</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>原生JS的map方法，只能遍历数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.map(function(value,index，array)&#123;</span><br><span class="line">&#x2F;&#x2F;第一个参数为遍历的元素</span><br><span class="line">&#x2F;&#x2F;第二个参数为当前元素的索引</span><br><span class="line">&#x2F;&#x2F;第三个参数为新数组，与当前数组的值相同</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-3-trim-str"><a href="#2-3-trim-str" class="headerlink" title="2.3 trim(str)"></a>2.3 trim(str)</h4><p>除去字符串两端的空格并返回一个新的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;     nabok       &quot;;</span><br><span class="line">var res &#x3D; $.trim(str);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-isArray-obj-是否为（0真数组（伪数组为false）"><a href="#2-4-isArray-obj-是否为（0真数组（伪数组为false）" class="headerlink" title="2.4 isArray(obj) 是否为（0真数组（伪数组为false）"></a>2.4 <strong>isArray(obj)</strong> 是否为（0真数组（伪数组为false）</h4><p>​     <strong>isfunction(obj)</strong> 是否为函数</p>
<pre><code>**iswindow(obj)** 是否为window对象</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [12,2,2];</span><br><span class="line">var res &#x3D; $.isArray(arr);</span><br></pre></td></tr></table></figure>

<h4 id="2-5-holdReady"><a href="#2-5-holdReady" class="headerlink" title="2.5 holdReady()"></a>2.5 holdReady()</h4><p>暂停或恢复ready函数的执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.holdReady(true);&#x2F;&#x2F;暂停</span><br><span class="line">$.holdReady(false);&#x2F;&#x2F;恢复</span><br></pre></td></tr></table></figure>

<h2 id="3-jQuery中常用的API"><a href="#3-jQuery中常用的API" class="headerlink" title="3.    jQuery中常用的API"></a>3.    jQuery中常用的API</h2><h3 id="1-属性和属性节点"><a href="#1-属性和属性节点" class="headerlink" title="1. 属性和属性节点"></a>1. 属性和属性节点</h3><p>属性：对象中保存的变量，通过    对象.属性名或对象[“属性名”]    设置或获取</p>
<p>属性节点：HTML标签中（DOM对象）的属性，位于标签下的attributes属性中，setAttributes(“”,””)设置，getAttributes(“”)获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;属性节点</span><br><span class="line">  attr(name|properties|key,value|fn)</span><br><span class="line">      一个参数时，返回第一个元素中指定节点的值</span><br><span class="line">      两个参数时，设置所有找到元素中指定节点的值，若不存在该节点则添加</span><br><span class="line">  removeAttr(attributeName)</span><br><span class="line">      删除所有找到元素的指定节点,多个节点以空格分隔 	  </span><br><span class="line">&#x2F;&#x2F;属性 </span><br><span class="line">  prop(name|properties|key,value|fn)</span><br><span class="line">  removeProp(propertyName)</span><br><span class="line">  与上面的方法相似</span><br></pre></td></tr></table></figure>

<h3 id="2-类操作"><a href="#2-类操作" class="headerlink" title="2. 类操作"></a>2. 类操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加类   多个类名空格隔开</span><br><span class="line">       addClass(className)</span><br><span class="line">     	  $(&quot;p&quot;).addClass(&quot;selected1 selected2&quot;);</span><br><span class="line">&#x2F;&#x2F;判断有没有指定的类，有，返回true，否则返回false   </span><br><span class="line">       hasClass(className)</span><br><span class="line">&#x2F;&#x2F;删除类   </span><br><span class="line">       removeClass(className)</span><br><span class="line">&#x2F;&#x2F;切换类	有则删除，没有则添加</span><br><span class="line">	  toggleClass(className)</span><br></pre></td></tr></table></figure>

<h3 id="3-文本值操作"><a href="#3-文本值操作" class="headerlink" title="3.文本值操作"></a>3.文本值操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html() 与原生js中的innerHTML一样</span><br><span class="line">   无参：获取html的值</span><br><span class="line">   有参数html：设置html的值</span><br><span class="line">  	 $(&quot;div&quot;).html(&quot;&lt;p&gt;mememe&lt;&#x2F;p&gt;&quot;);</span><br><span class="line">text() 与原生js中的innerText一样</span><br><span class="line">   无参：获取文本值</span><br><span class="line">   有参数text：设置文本值</span><br><span class="line">val()</span><br><span class="line">   无参：获取value的值</span><br><span class="line">   有参数value：设置value的值</span><br></pre></td></tr></table></figure>

<h3 id="4-样式操作"><a href="#4-样式操作" class="headerlink" title="4.样式操作"></a>4.样式操作</h3><p><strong>4.1    设置DOM元素的CSS样式</strong><br>        css(name|pro|[,val|fn]) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逐个设置</span><br><span class="line">$(&quot;div&quot;).css(&quot;width&quot;,&quot;100px&quot;);</span><br><span class="line">链式设置(不超过3次)</span><br><span class="line">$(&quot;div&quot;).css(&quot;width&quot;,&quot;100px&quot;).css(&quot;height&quot;,&quot;100px&quot;);</span><br><span class="line">批量设置</span><br><span class="line">$(&quot;div&quot;).css(&#123;</span><br><span class="line">width: &quot;100px&quot;,</span><br><span class="line">height: &quot;100px&quot;</span><br><span class="line">&#125;);</span><br><span class="line">获取样式值</span><br><span class="line">$(&quot;div&quot;).css(&quot;width&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>4.2    位置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">offset([coordinates]) </span><br><span class="line">position() </span><br><span class="line">scrollTop([val]) </span><br><span class="line">scrollLeft([val])</span><br></pre></td></tr></table></figure>

<p><strong>4.3    尺寸</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">heigh([val|fn]) </span><br><span class="line">width([val|fn]) </span><br><span class="line">innerHeight() </span><br><span class="line">innerWidth() </span><br><span class="line">outerHeight([soptions]) </span><br><span class="line">outerWidth([options])</span><br></pre></td></tr></table></figure>

<h3 id="5-jQuery中的工具方法"><a href="#5-jQuery中的工具方法" class="headerlink" title="5.    jQuery中的工具方法"></a>5.    jQuery中的工具方法</h3><p> <strong>1) get()</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;以数组的形式返回DOM节点，get(index)返回获取到的元素中第index个（从0开始）元素,dom本身</span><br><span class="line">$(&#39;div&#39;).get();</span><br></pre></td></tr></table></figure>

<p> <strong>2) toArray()</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回一个包含jQuery对象中的所有DOM元素数组。</span><br><span class="line">$(&#39;div&#39;).toArray();</span><br></pre></td></tr></table></figure>

<p><strong>3) eq(index)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;eq()，返回获取到的元素中第index个（从0开始）元素的jQuery对象</span><br><span class="line">$(&#39;div&#39;).eq(1);</span><br></pre></td></tr></table></figure>

<p>  <strong>4) filter(function(index,item){})</strong>;   //过滤器函数，返回jQuery对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var $result &#x3D; $(&#39;div&#39;).filter(function(index,item)&#123;</span><br><span class="line"> 	return index &#x3D;&#x3D; 2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <strong>5) map(function(index,item){})</strong>    //用于获取或设置元素集合中的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var $result &#x3D; $(&#39;div&#39;).map(function(index,item)&#123;</span><br><span class="line">    return $(item).html();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>6) each(function(index,item){})</strong>  //遍历一个jQuery对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;div&#39;).each(function(index,item)&#123;</span><br><span class="line">   console.log(index,&#39;--&#39;,item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>7)index()</strong>    //返回当前元素在兄弟节点中的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var index &#x3D; $(&quot;this&quot;).index();</span><br></pre></td></tr></table></figure>

<p><strong>8)sibilngs()</strong>    //返回非当前元素的所有兄弟节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var others &#x3D; $(this).siblings();</span><br></pre></td></tr></table></figure>

<h2 id="4-jQuery的事件"><a href="#4-jQuery的事件" class="headerlink" title="4.    jQuery的事件"></a>4.    jQuery的事件</h2><h3 id="4-1-事件的绑定和解绑"><a href="#4-1-事件的绑定和解绑" class="headerlink" title="4.1    事件的绑定和解绑"></a>4.1    事件的绑定和解绑</h3><p><strong>事件绑定</strong>（在一个元素上可以添加多个相同或不同的事件，不会覆盖）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.eventName(fn)	事件有智能提示，是jQuery已实现的部分事件</span><br><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">2.on(eventName,fn)	字符串形式，可以添加所有js事件</span><br><span class="line">$(&quot;button&quot;).on(&quot;click&quot;,function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>事件解绑</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">off()</span><br><span class="line">      移除一个事件处理函数,无参表示移除所有事件，一个参数表示移除所有指定类型的事件，两个参表示移除指定类型的指定事件</span><br><span class="line">      $(&quot;button&quot;).off();</span><br></pre></td></tr></table></figure>

<h3 id="4-2-事件冒泡和默认行为"><a href="#4-2-事件冒泡和默认行为" class="headerlink" title="4.2    事件冒泡和默认行为"></a>4.2    事件冒泡和默认行为</h3><p>事件冒泡：发生在子元素的事件会传递给其父元素，从而父元素的相同事件也会触发，比如点击子元素则在父元素绑定的点击事件也会触发。</p>
<p>阻止事件冒泡:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在子元素添加：</span><br><span class="line">1.return false;</span><br><span class="line">2.event.stopPropagation();</span><br></pre></td></tr></table></figure>

<p>默认行为：一些标签的默认事件，比如点击a标签会默认跳转，submit按钮默认提交</p>
<p>阻止默认行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在标签的绑定事件中：</span><br><span class="line">1.return false;</span><br><span class="line">2.event.preventDefaut();</span><br></pre></td></tr></table></figure>

<h3 id="4-3-事件自动触发"><a href="#4-3-事件自动触发" class="headerlink" title="4.3    事件自动触发"></a>4.3    事件自动触发</h3><p><strong>trigger()</strong>或<strong>triggerHandler()</strong><br>      自动触发匹配元素所有指定的事件类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.father&quot;).click(function()&#123;</span><br><span class="line">alert(&quot;123&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">$(&quot;.father&quot;).triggle(&quot;click&quot;);</span><br><span class="line">&#x2F;&#x2F;trigger()会触发事件冒泡和默认行为，而triggerHandler()不会触发事件冒泡或默认行为</span><br><span class="line">&#x2F;&#x2F;a标签比较特殊，如果想同时触发a的事件和默认行为，推荐在a中添加span标签并将事件绑定给他</span><br></pre></td></tr></table></figure>

<h3 id="4-4-自定义事件"><a href="#4-4-自定义事件" class="headerlink" title="4.4    自定义事件"></a>4.4    自定义事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个条件：</span><br><span class="line">1.事件通过on形式绑定。</span><br><span class="line">2.通过triggle自动触发</span><br></pre></td></tr></table></figure>

<h3 id="4-5-事件命名空间"><a href="#4-5-事件命名空间" class="headerlink" title="4.5    事件命名空间"></a>4.5    事件命名空间</h3><p>给事件打上标签，可以只触发相同事件的某一个</p>
<p>注意：triggle调用带命名空间的子元素事件时，会触发父元素带相同命名空间的事件，调用不带命名空间的子元素事件时，会触发父元素所有相同类型的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个条件：</span><br><span class="line">1.事件通过on形式绑定。</span><br><span class="line">2.通过triggle或triggleHandler自动触发</span><br><span class="line">$(&quot;button&quot;).on(&quot;click.kj&quot;,function()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-6-事件委托"><a href="#4-6-事件委托" class="headerlink" title="4.6    事件委托"></a>4.6    事件委托</h3><p>delegate(),将事件绑定到已有元素，由该元素触发事件并将结果反馈给指定元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery代码在所有dom元素加载完成就执行，因此动态创建的元素不能响应相应的事件，可采用事件委托解决(事件冒泡原理)</span><br><span class="line">$(&quot;ul&quot;).delegate(&quot;li&quot;,&quot;ckick&quot;,function()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-7-事件分类"><a href="#4-7-事件分类" class="headerlink" title="4.7    事件分类"></a>4.7    事件分类</h3><h3 id="4-7-1-鼠标事件"><a href="#4-7-1-鼠标事件" class="headerlink" title="4.7.1    鼠标事件"></a>4.7.1    鼠标事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">click()  单击</span><br><span class="line">dblclick()  双击</span><br><span class="line">hover()   悬停</span><br><span class="line">mousedown()  按下</span><br><span class="line">mouseup()  抬起</span><br><span class="line">mouseenter()  移入  不支持子元素</span><br><span class="line">mouseleave()  离开  不支持子元素 </span><br><span class="line">mouseout()   离开  支持子元素</span><br><span class="line">mouseover()  进入  支持子元素 （即移入子元素时会依次触发父元素的移出移入事件）</span><br><span class="line">mousemove()  移动</span><br></pre></td></tr></table></figure>

<h3 id="4-7-2-键盘事件"><a href="#4-7-2-键盘事件" class="headerlink" title="4.7.2    键盘事件"></a>4.7.2    键盘事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keypress()   按键按下</span><br><span class="line">keyup()   按键抬起</span><br><span class="line">keydown()   按键按下</span><br></pre></td></tr></table></figure>

<h3 id="4-7-3-表单事件"><a href="#4-7-3-表单事件" class="headerlink" title="4.7.3    表单事件"></a>4.7.3    表单事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">focus()  聚焦事件</span><br><span class="line">blur()    失去焦点事件</span><br><span class="line">change()  当元素的值发生改变时激发的事件</span><br><span class="line">select()  当textarea或文本类型的input元素中的文本被选择时触发的事件</span><br><span class="line">submit()  表单提交事件，绑定在form上</span><br></pre></td></tr></table></figure>

<h2 id="5-jQuery动画"><a href="#5-jQuery动画" class="headerlink" title="5.    jQuery动画"></a>5.    jQuery动画</h2><h3 id="5-1-展开收起动画"><a href="#5-1-展开收起动画" class="headerlink" title="5.1    展开收起动画"></a>5.1    展开收起动画</h3><h3 id="5-2-折叠下拉动画"><a href="#5-2-折叠下拉动画" class="headerlink" title="5.2    折叠下拉动画"></a>5.2    折叠下拉动画</h3><h3 id="5-3-谈入谈出动画"><a href="#5-3-谈入谈出动画" class="headerlink" title="5.3    谈入谈出动画"></a>5.3    谈入谈出动画</h3><h3 id="5-4-自定义动画"><a href="#5-4-自定义动画" class="headerlink" title="5.4    自定义动画"></a>5.4    自定义动画</h3><h1 id="三-jQuery原理（设计模式）"><a href="#三-jQuery原理（设计模式）" class="headerlink" title="三     jQuery原理（设计模式）"></a>三     jQuery原理（设计模式）</h1><p>封装自己的jquery框架</p>
<h2 id="1-jQery入口函数"><a href="#1-jQery入口函数" class="headerlink" title="1.    jQery入口函数"></a>1.    jQery入口函数</h2><h3 id="1-1-jQuery的基本结构"><a href="#1-1-jQuery的基本结构" class="headerlink" title="1.1     jQuery的基本结构"></a>1.1     jQuery的基本结构</h3><p>本质上是一个立即执行函数（即闭包），闭包可避免多框架变量名污染，通过window.xxx = xxx的形式暴露内部变量给外界，传递window实参的目的是方便后期压缩代码，提升查找效率，形参undefined的作用是方便压缩代码，兼容低版本IE浏览器，保障内部使用undefined不被修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(window,undefined)&#123;</span><br><span class="line">	var njQuery &#x3D; function()&#123;</span><br><span class="line">		return new njQuery.prototype.init();</span><br><span class="line">	&#125;</span><br><span class="line">	njQuery.prototype &#x3D; &#123;</span><br><span class="line">		constructor: njQuery</span><br><span class="line">	&#125;</span><br><span class="line">	njQuery.prototype.init.prototype &#x3D; njQuery.prototype;</span><br><span class="line">	window.njQuery &#x3D; window.$ &#x3D; njQuery;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-入口函数的返回值"><a href="#1-2-入口函数的返回值" class="headerlink" title="1.2    入口函数的返回值"></a>1.2    入口函数的返回值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.传入 &#39;&#39; null undefined NaN  0  false</span><br><span class="line">	返回空jQuery对象</span><br><span class="line">2.字符串:</span><br><span class="line">    html代码片段：会将创建好的DOM元素存储到jQuery对象中返回</span><br><span class="line">    选择器: 将找到的所有元素存储到jQuery对象中返回</span><br><span class="line">3.传入数组(真&#x2F;伪)</span><br><span class="line">	将数组中存储的元素依次存储到jQuery对象中返回</span><br><span class="line">4.除上述类型以外(对象、DOM元素、基本数据类型)</span><br><span class="line">    将传入的数据存储到jQuery对象中返回</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.charAt() --字符串的第几位字符</span><br><span class="line">children()	--	所选元素的下一级元素</span><br><span class="line">trim() -- 去除字符串的前后空格</span><br><span class="line">arr.replace(,) -- 替代</span><br><span class="line">push() -- 复制</span><br><span class="line">slice() -- 截取</span><br><span class="line">apply(),call() -- 强制修改方法内部的this</span><br><span class="line">	call(对象，[参数1，参数2……])</span><br><span class="line">	apply(对象，[数组])</span><br><span class="line">真伪数组的转换</span><br><span class="line">对方法分类管理，提高维护性extend()</span><br><span class="line">监听DOM元素是否加载完成</span><br><span class="line">	onload事件--等到DOM元素和资源加载完成才执行</span><br><span class="line">	DOMContentLoaded事件 -- 等到DOM元素加载完毕就执行</span><br><span class="line">	onreadystatechange事件 -- document.readyState变化事件（4次）</span><br><span class="line">	addEventListener(&quot;事件&quot;,fn())</span><br></pre></td></tr></table></figure>

<h3 id="1-3-原型上的属性"><a href="#1-3-原型上的属性" class="headerlink" title="1.3    原型上的属性"></a>1.3    原型上的属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jquery: &quot;1.1.0&quot;,	&#x2F;&#x2F;jQ版本号</span><br><span class="line">selector: &quot;&quot;,	&#x2F;&#x2F;实例默认的选择器取值</span><br><span class="line">length: 0,	&#x2F;&#x2F;实例默认的长度</span><br><span class="line">push: [].push,	&#x2F;&#x2F;给实例添加新元素</span><br><span class="line">sort: [].sort,	&#x2F;&#x2F;对实例中的元素进行排序</span><br><span class="line">splice: [].splice,	&#x2F;&#x2F;按照指定下标指定数量删除元素，也可以替换删除的元素</span><br></pre></td></tr></table></figure>

<h3 id="1-4-原型上的核心方法"><a href="#1-4-原型上的核心方法" class="headerlink" title="1.4    原型上的核心方法"></a>1.4    原型上的核心方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toArray 把实例转换为数组返回</span><br><span class="line">get  获取指定下标的元素，获取的是原生DOM</span><br><span class="line"></span><br><span class="line">eq 获取指定下标的元素，获取的是jQuery类型的实例对象</span><br><span class="line">first 获取实例中的第一个元素，是jQuery类型的实例对象</span><br><span class="line">last 获取实例中的最后一个元素，是jQuery类型的实例对象</span><br><span class="line"></span><br><span class="line">each 遍历实例，把遍历到的数据传给回调使用（工具方法与对象方法，返回原数据，this指向value）</span><br><span class="line">map  遍历实例，把遍历到的数据传给回调使用，然后把回调的返回值收集起来组成一个新的数组返回</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/%E7%AC%94%E8%AE%B0/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="廖雪峰Git教程学习笔记"><a href="#廖雪峰Git教程学习笔记" class="headerlink" title="廖雪峰Git教程学习笔记"></a>廖雪峰Git教程学习笔记</h2><h4 id="一-Git简介"><a href="#一-Git简介" class="headerlink" title="一.Git简介"></a>一.Git简介</h4><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br>版本控制系统：自动记录跟踪每次文件的改动，作一个文件快照，形成一个版本。<br>分布式版本控制系统：每个人电脑里都有完整的版本库，不必联网，中央服务器主要用于交换团队的修改。  </p>
<p>如：Mercurial、Bazaar、BitKeeper、Git  </p>
<p>集中式的版本控制系统：版本库是集中存放在中央服务器，必须联网才能工作。  </p>
<p>如：CVS、SVN  </p>
<p>历史：linux之父为了更好的管理他自己的开源项目linux系统而自己用C语言开发的分布式版本控制系统Git</p>
<h4 id="二-Git安装"><a href="#二-Git安装" class="headerlink" title="二.Git安装"></a>二.Git安装</h4><ul>
<li>Linux上安装</li>
</ul>
<p>1.判断是否已安装Git</p>
<pre><code>$ git</code></pre><p>2.否则</p>
<pre><code>Debian或Ubuntu Linux：
sudo apt-get install git
或
sudo apt-get install git-core（旧）</code></pre><p>其他：<br>从Git官网下载源码，解压，依次执行</p>
<pre><code>./config
make
sudo make install</code></pre><ul>
<li>Windows上安装Git</li>
</ul>
<p>1.从Git官网下载安装程序,直接安装（或<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ2l0LWluc3RhbGxlci9naXQtZm9yLXdpbmRvd3PvvIk=" title="https://gitee.com/git-installer/git-for-windows）">https://gitee.com/git-installer/git-for-windows）<i class="fa fa-external-link"></i></span><br>2.配置</p>
<pre><code>$ git config --global user.name &quot;Your Name&quot;//名字
$ git config --global user.email &quot;email@example.com&quot;//邮箱</code></pre><h4 id="三-创建版本库-repository-仓库-目录"><a href="#三-创建版本库-repository-仓库-目录" class="headerlink" title="三.创建版本库(repository/仓库/目录)"></a>三.创建版本库(repository/仓库/目录)</h4><p>1.选择一个合适的地方，创建一个空目录</p>
<pre><code>$ mkdir learngit    //创建一个空文件夹（如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。）
$ cd learngit    //移动到新文件夹
$ pwd    //显示当前位置的路径</code></pre><p>2.初始化目录，将其变成Git可以管理的仓库</p>
<pre><code>$ git init    //初始化
$ git ls -ah     //罗列目录下的文件</code></pre><p>成功会自动创建.git文件夹，Git用来跟踪管理版本库<br>所有的版本控制系统只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等<br>无法跟踪图片、视频、Word等二进制文件的变化<br>Windows自带记事本的文本文件开头有个0xefbbbf，可能编译错误，不推荐</p>
<h4 id="四-把文件添加到版本库-文件在同一文件夹"><a href="#四-把文件添加到版本库-文件在同一文件夹" class="headerlink" title="四.把文件添加到版本库(文件在同一文件夹)"></a>四.把文件添加到版本库(文件在同一文件夹)</h4><p>1.把文件添加到仓库</p>
<pre><code>$ git add file    //反复多次使用，添加多个文件，把文件修改添加到暂存区</code></pre><p>2.把文件提交到仓库</p>
<pre><code>$ git commit -m &quot;description&quot;    //一次提交，把暂存区的所有内容提交到当前分支</code></pre><h4 id="五-穿梭功能"><a href="#五-穿梭功能" class="headerlink" title="五.穿梭功能"></a>五.穿梭功能</h4><p>1.基本概念<br>工作区（Working Directory）：存在文件的目录<br>版本库（Repository）：.git文件夹<br>暂存区（stage或index）：<br>分支（branch）：<br>master分支：Git自动创建的唯一一个主分支<br>commit id：版本号<br>HEAD：表示当前版本 HEAD^：上一个版本 HEAD^^：上上一个版本 ……  HEAD~100：上100个版本</p>
<pre><code>$ git status    //查看仓库当前的状态
$ git diff file    //查看已修改未提交内容与最新版本的不同</code></pre><p>2.版本回退</p>
<pre><code>$ git log或$ git log --pretty=oneline    //显示从最近到最远的提交日志
$ git reset --hard HEAD^    //回退到上一个版本
$ git reset --hard 1094a    //回到1094adb...版本0
$ git reflog    //查看命令日志</code></pre><p>原理：Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向该版本号并更新工作区的文件</p>
<p>3.管理修改<br>每次修改，如果不用git add到暂存区，那就不会加入到commit中。</p>
<pre><code>git diff HEAD -- file    //查看工作区和版本库里面最新版本的区别.</code></pre><p>4.撤销修改<br>人工修改</p>
<pre><code>$ git checkout -- file    //丢弃工作区的修改
$ git reset HEAD &lt;file&gt;    //撤销暂存区的修改</code></pre><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，不过前提是没有推送到远程库。<br>5.删除文件</p>
<pre><code>$ rm file    //删除文件管理器的文件
$ git rm file    //从版本库中删除文件
$ git checkout -- file。//恢复错删文件</code></pre><h4 id="六-远程仓库"><a href="#六-远程仓库" class="headerlink" title="六.远程仓库"></a>六.远程仓库</h4><p>Github–&gt;Git远程仓库</p>
<h5 id="SSH加密："><a href="#SSH加密：" class="headerlink" title="SSH加密："></a>SSH加密：</h5><p>1.创建SSH Key</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><p>2.登陆GitHub，打开“Account settings”，“SSH Keys”页面，<br>点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p>
<h5 id="添加远程库："><a href="#添加远程库：" class="headerlink" title="添加远程库："></a>添加远程库：</h5><p>1.Github上创建repository<br>2.本地仓库关联github的远程库<br>$ git remote add origin <span class="exturl" data-url="bWFpbHRvOmdpdEBnaXRodWIuY29t" title="mailto:git@github.com">git@github.com<i class="fa fa-external-link"></i></span>:用户名/远程仓库名.git<br>3.把本地仓库的内容推送到GitHub仓库<br>$ git push -u origin master<br>4.推送最新修改<br>$ git push origin master</p>
<h5 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h5><p>1.确定Github上repository的地址<br>2.克隆远程库到本地</p>
<pre><code>$ git clone git@github.com:用户名/仓库名.git</code></pre><h4 id="七-分支管理"><a href="#七-分支管理" class="headerlink" title="七.分支管理"></a>七.分支管理</h4><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。<br>一开始，只有一条时间线，在Git里，这个分支叫主分支，即master分支。<br>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支<br>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。<br>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变<br>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并</p>
<h5 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h5><p>1.创建分支</p>
<pre><code>$ git checkout -b dev

或
$ git branch dev    //创建分支
$ git checkout dev    //切换分支

$ git branch    //查看分支</code></pre><p>2.修改文件后切换回master分支</p>
<pre><code>$ git checkout master</code></pre><p>3.把dev分支的工作成果合并到master分支上</p>
<pre><code>$ git merge dev</code></pre><p>4.删除dev分支</p>
<pre><code>$ git branch -d dev</code></pre><h5 id="解决分支冲突"><a href="#解决分支冲突" class="headerlink" title="解决分支冲突"></a>解决分支冲突</h5><p>分支冲突：要合并的分支在同一提交点上有不同的修改<br>解决方法：把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<pre><code>$ git status    //可查看冲突文件
$ git log --graph --pretty=oneline --abbrev-commit //查看分支合并图</code></pre><h5 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h5><pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 

//强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，从分支历史上就可以看出分支信息</code></pre><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面实战一下–no-ff方式的git merge：</p>
<p>首先，仍然创建并切换dev分支：</p>
<pre><code>$ git checkout -b dev
Switched to a new branch &apos;dev&apos;</code></pre><p>修改readme.txt文件，并提交一个新的commit：</p>
<pre><code>$ git add readme.txt 
$ git commit -m &quot;add merge&quot;</code></pre><p>切换回master：</p>
<pre><code>$ git checkout master
Switched to branch &apos;master&apos;</code></pre><p>合并dev分支，注意–no-ff参数，表示禁用Fast forward：</p>
<pre><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></pre><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p>
<h5 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h5><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；<br>干活都在dev分支上，也就是说，dev分支是不稳定的。<br>到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本<br>团队每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并</p>
<h6 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h6><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除</p>
<pre><code>$ git stash        //把当前工作现场“储藏”起来，等以后恢复现场后继续工作
或
$ git stash apply stash@{0}        //恢复指定的stash
$ git stash list    //查看已存放的工作现场

$ git stash apply    //恢复工作现场
$ git stash drop    //删除stash内容
或
$ git stash pop        //恢复并删除stash内容</code></pre><h6 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h6><p>开发一个新feature，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除</p>
<h6 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h6><pre><code>$ git remote    //查看远程库的信息
$ git remote -v        //示更远程库详细的信息</code></pre><h6 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h6><p>把某分支上的所有本地提交推送到远程库。<br>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上</p>
<pre><code>$ git push origin master</code></pre><p>推送原则：<br>master分支是主分支，因此要时刻与远程同步；</p>
<p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<h6 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支."></a>抓取分支.</h6><pre><code>$ git clone git@github.com:michaelliao/learngit.git    //克隆，只有master分支
$ git checkout -b dev origin/dev    //创建与远程origin的相应的分支</code></pre><p>当其他人已推送的的最新提交和你试图推送的提交有冲突，往往推送失败<br>解决方法：先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送</p>
<pre><code>$ git branch --set-upstream-to=origin/dev dev    //指定本地dev分支与远程origin/dev分支的链接
$ git pull    //抓取分支</code></pre><h5 id="多人协作流程："><a href="#多人协作流程：" class="headerlink" title="多人协作流程："></a>多人协作流程：</h5><p>查看远程库信息，使用git remote -v；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p>
<p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<h5 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h5><p>把分叉的提交历史“整理”成一条直线，看上去更直观，但本地的分叉提交已经被修改过了</p>
<pre><code>$ git rebase    //把本地未push的分叉提交历史整理成直线</code></pre><h4 id="八-标签管理"><a href="#八-标签管理" class="headerlink" title="八.标签管理"></a>八.标签管理</h4><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），<br>这样，就唯一确定了打标签时刻的版本。<br>将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。<br>所以，标签也是版本库的一个快照，实质上也是指向某个commit的指针，但不能移动</p>
<h5 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h5><p>切换到需要打标签的分支，敲命令git tag <name>就可以打一个新标签</p>
<pre><code>$ git tag    //查看所有标签，按字母排序的
$ git tag v0.9 f52c633    //给指定commit id打标签
$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb        //创建带有说明的标签
$ git show &lt;tagname&gt;    //查看标签信息</code></pre><h5 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h5><pre><code>$ git tag -d v0.1    //删除本地标签
git push origin &lt;tagname&gt;    //推送某个标签到远程
$ git push origin --tags    //一次性推送全部尚未推送到远程的本地标签

$ git tag -d v0.9
$ git push origin :refs/tags/v0.9    //删除远程标签</code></pre>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>李立超JS视频教程学习笔记</title>
    <url>/%E7%AC%94%E8%AE%B0/%E6%9D%8E%E7%AB%8B%E8%B6%85JS%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="李立超JS视频教程学习笔记（持续更新）"><a href="#李立超JS视频教程学习笔记（持续更新）" class="headerlink" title="李立超JS视频教程学习笔记（持续更新）"></a>李立超JS视频教程学习笔记（持续更新）</h2><h3 id="001-简介"><a href="#001-简介" class="headerlink" title="001 简介"></a>001 简介</h3><p>1.95年诞生，Netscape创建，用于网页的前端验证；<br>2.同年，微软创建JScript；<br>3.制定统一标准ECMAScript<br>4.标准的实现称为JS引擎，如Chrome的v8引擎<br>5.JavaScript包括ECMAScript,DOM,BOM<br>6.特点：</p>
<ul>
<li>解释型语言（不用编译，直接运行）</li>
<li>类似于C和JAVA的语法结构</li>
<li>动态语言</li>
<li>基于原型的面向对象</li>
</ul>
<h3 id="002-Hello"><a href="#002-Hello" class="headerlink" title="002 Hello"></a>002 Hello</h3><p>三条输出语句</p>
<pre><code>alert(&quot;Hello World!&quot;);
document.write(&quot;我的第一行JS代码！&quot;);
console.log(&quot;写入到开发者控制台&quot;);  </code></pre><h3 id="003-代码编写位置"><a href="#003-代码编写位置" class="headerlink" title="003 代码编写位置"></a>003 代码编写位置</h3><p>JS代码编写位置<br>1.<code>&lt;script&gt;&lt;/script&gt;</code>标签中，可写多个；<br>2.外部文件.js中,<code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code>引入，标签内不能再编写代码，不执行；<br>3.HTML标签的onclick属性中，点击后代码才会执行；<br>4.超链接&lt;a&gt;的href属性中,点击超链接将执行代码，href=”javascript: “;  </p>
<p>(位置3、4 结构与行为耦合，不方便维护，不推荐）</p>
<h3 id="004-基本语法"><a href="#004-基本语法" class="headerlink" title="004 基本语法"></a>004 基本语法</h3><p>1.注释 （查看、维护、合作、简单调试）</p>
<pre><code>单行注释  //
多行注释  /*

           */
或
/*
*
*
*/</code></pre><p>2.严格区分大小<br>3.每一条语句以分号 ; 结尾，可不用但会浪费系统资源甚至可能出错，不推荐<br>4.自动忽略多个空格和换行，以此对代码进行格式化，美观</p>
<h3 id="005-字面量和变量"><a href="#005-字面量和变量" class="headerlink" title="005 字面量和变量"></a>005 字面量和变量</h3><p>1.字面量：<br>一些不可改变的值，如1，2，1693587469695等<br>可以直接使用，但一般不会直接使用，麻烦<br>2.变量 ：<br>可以用来保存字面量，其值可以任意改变，通过变量名对字面量进行描述，方便使用<br>声明变量 var a；(variable)<br>赋值a = 0226;<br>var a = 0226;</p>
<h3 id="006-标识符"><a href="#006-标识符" class="headerlink" title="006 标识符"></a>006 标识符</h3><p>标识符：js中所有可以自主命名的都可以称为标识(zhi)符，例如变量名，函数名，属性名……  </p>
<p>命名规则：<br>1.标识符中可以含有字母、数字、_、$<br>2.不能以数字开头<br>3.不能是ES中的关键字或保留字，如var,if…（皇帝名）<br>4.一般采用驼峰命名法-首字母小写，每个单词开头字母大写，其余字母小写-<br>5.JS底层保存标识符时采用Unicode编码即utf-8，理论上可用utf-8中所有内容命名，包括中文，但一般不用</p>
<h3 id="007-010-数据类型和基本数据类型"><a href="#007-010-数据类型和基本数据类型" class="headerlink" title="007-010 数据类型和基本数据类型"></a>007-010 数据类型和基本数据类型</h3><p>1.数据类型指的就是字面量的类型<br>2.JS中共有六种数据类型：</p>
<pre><code>String         字符串
Number     数值
Boolean     布尔值
Null            空值
Undefined 未定义
Object        对象</code></pre><p>其中String、Number、Boolean、Null、Undefined属于基本数据类型，而Object属于引用数据类型。</p>
<h4 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h4><p>使双引号或单引号引起来<br>不能混着用，不能自我嵌套，但可互相嵌套<br>在字符串中可以使用\作为转义字符，本身\可用\表示<br>&quot; 表示”<br>\n 换行<br>\t  制表符</p>
<h4 id="数值Number"><a href="#数值Number" class="headerlink" title="数值Number"></a>数值Number</h4><p>所有数值都是Number类型，整数和浮点数<br>运算符typeof检查变量类型，语法：typeof 变量名<br>数的最大值:Number.MAX_VALUE，相当于常量1.7697691348623157e+308；Number.MIN_VALUE表示大于0的最小值，相当于5e-324<br>比Number.MAX-VALUE大的数值会返回Infinity字面量表示无穷大，不是数值则返回NaN即Not A Number（非法数字）<br>在JS中整数的运算基本可以保证准确，但浮点运算可能得到一个不准确的结果（二进制本身的问题，所有语言都存在，但目前JS没有有效的解决方法）</p>
<h4 id="布尔值Boolean"><a href="#布尔值Boolean" class="headerlink" title="布尔值Boolean"></a>布尔值Boolean</h4><p>用于逻辑判断<br>只有两个值：true真，false假</p>
<h4 id="空值Null"><a href="#空值Null" class="headerlink" title="空值Null"></a>空值Null</h4><p>用来表示一个空的对象，其数据类型实质为object<br>只有一个值：null</p>
<h4 id="未定义Undefined"><a href="#未定义Undefined" class="headerlink" title="未定义Undefined"></a>未定义Undefined</h4><p>当声明变量但未赋值时，变量值默认为undefined，数据类型就是undefined<br>只有一个值：undefined</p>
<h3 id="011-012-强制类型转换"><a href="#011-012-强制类型转换" class="headerlink" title="011-012 强制类型转换"></a>011-012 强制类型转换</h3><p>强制类型转换:将一个数据强制转换成其他的数据类型，主要指String，Number，Boolean<br>1.转换为String<br>法1：调用被转换数据类型的toString()方法<br>    该方法不会影响原变量的数据类型<br>    null和undefined没有toString方法</p>
<pre><code>例 a = a.toString()</code></pre><p>法2：调用String()函数，将被转换的数据作为参数传递给函数  </p>
<pre><code>对于Number和Boolean实质上就是调用toString()方法,对于null和undefined则是直接加上引号</code></pre><p>2.转换为Number<br>法1：调用Number()函数</p>
<pre><code>字符串--&gt;数字
    1.纯数字字符串--&gt;相应数字
    2.含有非数字内容的字符串--&gt;NaN
    3.空串或只含空格的字符串--&gt;0
布尔--&gt;数字
    true--&gt;1
    false--&gt;0
null--&gt;数字 ==0
undefined--&gt;数字 ==NaN</code></pre><p>法2：parseInt()函数 将字符串（其中的有效整数，从左到右）转换为整数<br>         parseFloat()函数 将字符串（其中的有效浮点数，从左到右）转换为浮点数<br>         本质上是将数据转换为字符串再将其中的有效数字转换为相应的数字</p>
<pre><code>例：parseInt(&quot;123.45px&quot;)==123
    parseInt(&quot;abc&quot;)==NaN
    parseInt(null)==NaN
    parseFloat(&quot;123.456px&quot;)==123.456</code></pre><h3 id="013不同进制数字的表示"><a href="#013不同进制数字的表示" class="headerlink" title="013不同进制数字的表示"></a>013不同进制数字的表示</h3><pre><code>16进制以0x开头
8进制以0开头
2进制以0b开头，某些浏览器不支持，如IE
特殊情况：在parseInt()函数中，比如a=&quot;070&quot;，不同浏览器会将其看成不同进制的数字，
因此要在parseInt()中添加第二个参数表示不同进制`parseInt(a,10)`</code></pre><h3 id="014-强制类型转换"><a href="#014-强制类型转换" class="headerlink" title="014 强制类型转换"></a>014 强制类型转换</h3><pre><code>--&gt;Boolean
调用Boolean()函数
数字--&gt;布尔
除了0和NaN为false，其余为true
字符串--&gt;布尔
除了空串为false，其余为true
null和undefined都为false
对象--&gt;布尔 ==true</code></pre><h3 id="015-运算符和算数运算符"><a href="#015-运算符和算数运算符" class="headerlink" title="015 运算符和算数运算符"></a>015 运算符和算数运算符</h3><p>运算符也叫操作符，通过对一个或多个值进行运算，并获取运算结果<br>如typeof，可以获得一个值的类型并保存为字符串的形式</p>
<h4 id="算数运算符（二元运算符）"><a href="#算数运算符（二元运算符）" class="headerlink" title="算数运算符（二元运算符）"></a>算数运算符（二元运算符）</h4><pre><code>非Number类型的值进行运算会转换成相应Number值（+运算例外）
任何值和NaN进行运算都为NaN</code></pre><p>1.+ 加法运算，并返回结果<br>任何值和字符串作+运算，会进行拼串即将其转换为字符串后拼接成一个字符串<br>利用空串可将任意数据转换为String类型，如a = a +””(隐式的类型转换，实际上也是调用String函数)</p>
<ol start="2">
<li><ul>
<li>减法运算</li>
</ul>
</li>
<li><ul>
<li>乘法运算</li>
</ul>
</li>
<li>/ 除法运算<br>任何值做- * /运算时都会自动转换为Number，以此通过-0 *1 /1将非Number值隐式转为Number类型</li>
<li>% 取模运算(取余数)</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>我的时区</title>
    <url>/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<p>分享一首小诗</p>
<blockquote>
<p>每个人都有自己的时区<br>纽约时间比加州时间早三个小时，<br>但加州时间并没有变慢。<br>有人22岁就毕业了，<br>但等了五年才找到好的工作！<br>有人25岁就当上了CEO，<br>却在50岁去世。<br>也有人迟到50岁才当上CEO，<br>然后活到90岁。<br>有人依然单身，<br>同时也有人已婚。<br>奥巴马55岁就退休，<br>川普70岁才开始当总统。<br>世上每个人本来就有自己的发展时区。<br>身边有些人看似走在你前面，<br>也有人看似走在你后面。<br>但其实每个人在自己的时区都有自己的步伐。<br>不用嫉妒或嘲笑他们。<br>他们都在记得时区里，你也是！<br>生命就是等待正确的是行动时机。<br>所以，放轻松。<br>你没有落后。<br>你没有领先。<br>在命运为你安排的属于自己的时区里，一切都准时。</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>poem</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack笔记</title>
    <url>/%E7%AC%94%E8%AE%B0/webpack%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="webpack笔记"><a href="#webpack笔记" class="headerlink" title="webpack笔记"></a>webpack笔记</h1><h2 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h2><h3 id="1-前端模块化开发的历程"><a href="#1-前端模块化开发的历程" class="headerlink" title="1.前端模块化开发的历程"></a>1.前端模块化开发的历程</h3><p>早期js仅作为脚本语言，处理表单验证、动画实现等</p>
<p>|    |    代码写在·<script>·标签插入页面</p>
<p>ajax异步请求出现，前后端分离，代码越来越复杂</p>
<p>|    |    代码写在js文件再引入（出现 全局变量污染，js文件引用顺序依赖等问题）</p>
<p>函数作用域的运用</p>
<p>|    |    匿名函数（闭包）解决变量重名问题（代码不可复用）</p>
<p>出现模块化雏形</p>
<p>|    |    在匿名函数内部return某个对象，里面包含要导出的变量或方法，在其他js文件中可使用该对象（ES5的导入导出）</p>
<p>出现模块化的规范</p>
<p>|    |    CommonJS，AMD，CMD，ES6的modules，核心都是导入导出（CommonJS的实现代表node.js）</p>
<h3 id="2-常用模块化规范的基本语法"><a href="#2-常用模块化规范的基本语法" class="headerlink" title="2.常用模块化规范的基本语法"></a>2.常用模块化规范的基本语法</h3><h4 id="2-1-CommonJS"><a href="#2-1-CommonJS" class="headerlink" title="2.1    CommonJS"></a>2.1    CommonJS</h4><p>CommonJS的导入导出，需要底层支撑才能解析代码，比如在node环境下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">导出：</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	flag:flag <span class="comment">//简写flag</span></span><br><span class="line">&#125;</span><br><span class="line">导入：</span><br><span class="line"><span class="keyword">let</span> &#123;flag&#125; = <span class="built_in">require</span>(<span class="string">'./index.js'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-ES6"><a href="#2-2-ES6" class="headerlink" title="2.2    ES6"></a>2.2    ES6</h4><p>ES6的导入导出,大部分浏览器已实现，可直接使用</p>
<p>引入：<code>&lt;script src=&quot;index.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></p>
<p>加上module类型，意味着该js文件为一个模块，对外是封闭的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">导出：</span><br><span class="line"><span class="number">1.</span>定义后统一导出</span><br><span class="line">	<span class="keyword">export</span> &#123;</span><br><span class="line">		flag</span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">2.</span>定义时导出</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="number">3.</span>默认导出，可不命名，由导入者命名，一个模块只能有一个</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> flag;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">导入：</span><br><span class="line"><span class="number">1.</span>基本的导入</span><br><span class="line">	<span class="keyword">import</span> &#123;flag&#125; <span class="keyword">from</span> <span class="string">"./index.js"</span>;</span><br><span class="line"><span class="number">2.</span>导入某个模块通过<span class="keyword">export</span> <span class="keyword">default</span>导出的功能（自己命名）</span><br><span class="line">	<span class="keyword">import</span> fn <span class="keyword">from</span> <span class="string">"./index.js"</span>;</span><br><span class="line"><span class="number">3.</span>导入某个模块所有导出的功能,通过<span class="keyword">as</span>后的变量调用</span><br><span class="line">	<span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">"./index.js"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-初识webpack"><a href="#3-初识webpack" class="headerlink" title="3.初识webpack"></a>3.初识webpack</h3><p>At its core,webpack is a static module bundler for modern JavaScript applications.(静态模块打包工具)</p>
<p><strong>模块</strong>：给前端模块化开发提供底层支持并处理模块间的依赖关系，让开发更有效率（底层支撑，关系处理）</p>
<p><strong>打包</strong>：将各种资源模块（js,less,sass,json,png等）转换并打包成浏览器可识别的一个或多个包（转换打包）</p>
<p>要在node环境下运行(且node依赖很多包，通过npm管理)，只是开发时的工具，完成打包后只需将打包文件部署到服务器</p>
<p>注：可完成打包功能的其它工具grunt/gulp（前端自动化任务管理工具）</p>
<p>核心为task（任务），通过定义task要处理的事务并依次执行这些task，适用于模块依赖简单的项目。</p>
<p>对比：grunt/gulp强调前端流程的自动化</p>
<p>​           webpack强调模块化开发管理</p>
<h2 id="二、webpack安装和使用"><a href="#二、webpack安装和使用" class="headerlink" title="二、webpack安装和使用"></a>二、webpack安装和使用</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.    安装"></a>1.    安装</h3><h4 id="1-1-安装node-js-包含npm"><a href="#1-1-安装node-js-包含npm" class="headerlink" title="1.1.安装node.js(包含npm)"></a>1.1.安装node.js(包含npm)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网：http;&#x2F;&#x2F;nodejs.cn&#x2F;download&#x2F;</span><br><span class="line">下载安装NodeJS,自动包含npm工具(Node Package Manager,nodejs的包管理和分发工具，可以用来安装开发依赖的模块)</span><br><span class="line">检查安装版本：</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">npm使用淘宝镜像(使用cnpm命令安装包）：</span><br><span class="line">npm install -g cnpm --registry&#x3D;http;&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h4 id="1-2-全局安装webpack"><a href="#1-2-全局安装webpack" class="headerlink" title="1.2.全局安装webpack"></a>1.2.全局安装webpack</h4><p>终端执行webpack命令时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line"></span><br><span class="line">npm install webpack@3.6.0 -g	&#x2F;&#x2F;vue cli2依赖webpack3.6.0</span><br><span class="line"></span><br><span class="line">webpack -version	&#x2F;&#x2F;查看webpack版本</span><br></pre></td></tr></table></figure>

<h4 id="1-3-局部安装webpack"><a href="#1-3-局部安装webpack" class="headerlink" title="1.3.局部安装webpack"></a>1.3.局部安装webpack</h4><p>package.json中script脚本的webpack命令优先使用局部webpack，避免版本不一致问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack@3.6.0 --save-dev	&#x2F;&#x2F;--save-dev代表开发时依赖，开发阶段需要的包、工具等</span><br></pre></td></tr></table></figure>

<h3 id="2-基本使用（webpack4-41-2）"><a href="#2-基本使用（webpack4-41-2）" class="headerlink" title="2.    基本使用（webpack4.41.2）"></a>2.    基本使用（webpack4.41.2）</h3><p>通过命令 <code>webpack .\src\main.js -o .\dist\bundle.js</code>进行打包，只需要一个入口和出口，webpack会自动处理其中的依赖关系，将与入口相关的文件根据依赖一起打包。(dist=distribution 发布)</p>
<p><img src="E:%5CWebTime%5Cwebpack%5Cimgages%5C%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="目录结构"></p>
<h3 id="3-webpack基本配置"><a href="#3-webpack基本配置" class="headerlink" title="3.    webpack基本配置"></a>3.    webpack基本配置</h3><h4 id="3-1-初始化项目"><a href="#3-1-初始化项目" class="headerlink" title="3.1    初始化项目"></a>3.1    初始化项目</h4><p>使用node环境相关的包时先进行初始化 <code>npm init</code>，会创建一个package.json文件（项目的配置描述文件），通过npm命令安装新依赖时会自动更新文件</p>
<h4 id="3-2-package-json配置"><a href="#3-2-package-json配置" class="headerlink" title="3.2    package.json配置"></a>3.2    package.json配置</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"learn"</span>,	<span class="comment">//项目名</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,	<span class="comment">//版本号</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,	<span class="comment">//描述</span></span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,	<span class="comment">//项目入口函数</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;			<span class="comment">//脚本</span></span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">     <span class="attr">"build"</span>: <span class="string">"webpack"</span>	<span class="comment">//npm run build == webpack（局部）</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,	<span class="comment">//作者</span></span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,	<span class="comment">//开源</span></span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;	<span class="comment">//开发时依赖</span></span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^3.6.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="string">"dependencies"</span>: &#123;	<span class="comment">//运行时依赖</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-webpack-config-js配置"><a href="#3-2-webpack-config-js配置" class="headerlink" title="3.2    webpack.config.js配置"></a>3.2    webpack.config.js配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)	<span class="comment">//node环境依赖的包</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//配置入口和出口，webpack = webpack ./src/main.js -o ./dist/bundle.js</span></span><br></pre></td></tr></table></figure>

<h3 id="4-webpack的转换功能loader"><a href="#4-webpack的转换功能loader" class="headerlink" title="4.    webpack的转换功能loader"></a>4.    webpack的转换功能loader</h3><p>webpack 的基本功能是处理js代码及其依赖关系，当需要处理css等文件时需要安装额外的loader，比如将 scss、less 转为 css，TypeScript 转为 ES5 代码、ES6 转 ES5、.vue或.jsx文件转为js文件等</p>
<p>loader的基本使用（具体看官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9sb2FkZXJzL++8ie+8mg==" title="https://www.webpackjs.com/loaders/）：">https://www.webpackjs.com/loaders/）：<i class="fa fa-external-link"></i></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>通过npm安装需要的loader</span><br><span class="line"><span class="number">2.</span>在webpack.config.js中的modules关键字下进行配置</span><br></pre></td></tr></table></figure>

<h4 id="4-1-使用css文件的配置"><a href="#4-1-使用css文件的配置" class="headerlink" title="4.1    使用css文件的配置"></a>4.1    使用css文件的配置</h4><p>css-loader     负责加载css代码</p>
<p>style-loader    负责添加样式到DOM</p>
<p>1.安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br><span class="line">npm install style-loader --save-dev</span><br></pre></td></tr></table></figure>

<p>2.配置(webpack.config.js中)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,	<span class="comment">//匹配css文件</span></span><br><span class="line">                use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]	<span class="comment">//多个loader从右到左依次加载执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-使用less文件"><a href="#4-2-使用less文件" class="headerlink" title="4.2    使用less文件"></a>4.2    使用less文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line">npm install --save-dev less-loader less</span><br><span class="line">//less-loader	负责加载less文件</span><br><span class="line">//less	node环境的包，负责支持将less转为css</span><br><span class="line">2.</span><br><span class="line">module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            <span class="built_in">test</span>: /\.less$/,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span> // creates style nodes from JS strings</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span> // translates CSS into CommonJS</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"less-loader"</span> // compiles Less to CSS</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-使用图片文件"><a href="#4-3-使用图片文件" class="headerlink" title="4.3     使用图片文件"></a>4.3     使用图片文件</h4><p>webpack将图片看作模块，当在css文件中引用是会会根据依赖打包相应的图片</p>
<p>（jpg是jpeg的另一种说法，早期的DOS系统只支持最多三个字母的后缀名文件，如htm（即html））</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">npm install --save-dev url-loader</span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        publicPath: <span class="string">'dist/'</span>	<span class="comment">//涉及到url的文件在打包时会自动拼接上该路径</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">//当图片小于该值，url-loader会将图片转成Base64字符串直接应用在页面上</span></span><br><span class="line">              <span class="comment">//当图片大于该值会使用file-loader，将图片用32位哈希值重命名并直接将路径返回给使用者，该loader不用配置，下载即可用</span></span><br><span class="line">               limit: <span class="number">8192</span>,</span><br><span class="line">               name: <span class="string">'img/[name].[hash:8].[ext]'</span>	<span class="comment">//指定打包路径并自定义命名文件</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-ES6转ES5"><a href="#4-4-ES6转ES5" class="headerlink" title="4.4    ES6转ES5"></a>4.4    ES6转ES5</h4><p>webpack默认打包js文件不会将ES6转ES5，需要使用babel对应的loader</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">npm install --save-dev babel-loader@<span class="number">7</span> babel-core babel-preset-es2015</span><br><span class="line"><span class="comment">//babel-loader@7 负责加载ES6文件</span></span><br><span class="line"><span class="comment">//babel-core 底层支持</span></span><br><span class="line"><span class="comment">//babel-preset-es2015 配置相关，es5转es6</span></span><br><span class="line"><span class="comment">//babel-preset-env 选择这个命令需要额外配置babelrc文件</span></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,	<span class="comment">//排除，与include(包含)相反</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-使用vue"><a href="#4-5-使用vue" class="headerlink" title="4.5     使用vue"></a>4.5     使用vue</h4><p><strong>安装：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install vue --save	<span class="comment">//运行时也需要vue</span></span><br></pre></td></tr></table></figure>

<p><strong>引入：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br></pre></td></tr></table></figure>

<p><strong>使用：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">'Hello webpack'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>错误：</strong></p>
<p><img src="E:%5CWebTime%5Cwebpack%5Cimgages%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(83).png" alt=""></p>
<p><strong>原因：</strong></p>
<p>vue在构建的时候会发布两个版本runtime-only(代码中不允许有template，无法编译)和runtime-compiler（可以编译template）</p>
<p><strong>解决</strong>（webpack.config.js)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;	<span class="comment">//别名</span></span><br><span class="line">      <span class="string">'vue$'</span> : <span class="string">'vue/dist/vue.esm.js'</span>	<span class="comment">//指定vue的具体路径，使用vue/dist/vue.esm.js（可编译template）</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终使用方案：</strong></p>
<p>安装：</p>
<p>vue-loader    //加载.vue文件</p>
<p>vue-template-compiler    //编译template</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">（webpack.config.js中)</span><br><span class="line">	&#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'vue-loader'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>vue组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;tittle&quot;&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;Cpn&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import Cpn from &#39;.&#x2F;Cpn&#39;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;App&quot;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            Cpn</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                message: &#39;Heloo Webpack&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.tittle&#123;</span><br><span class="line">    color: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>使用vue组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./vue/App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;App/&gt;`</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">        App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>额外任务：Bade64，Babel，webpack_require</p>
<h3 id="5-webpack的扩展功能plugin"><a href="#5-webpack的扩展功能plugin" class="headerlink" title="5.    webpack的扩展功能plugin"></a>5.    webpack的扩展功能plugin</h3><h4 id="5-1-webpack-Plugin的使用"><a href="#5-1-webpack-Plugin的使用" class="headerlink" title="5.1    webpack Plugin的使用"></a>5.1    webpack Plugin的使用</h4><p>webpack插件，对webpack现有功能的扩展，比如打包优化，文件压缩等</p>
<p>loader：文件的加载器、转换器</p>
<p>plugin：webpack的扩展器</p>
<p><strong>Plugin的基本使用：</strong></p>
<p>1.通过npm安装需要使用的Plugin（webpack已内置一些plugin，比如BannerPlugin）</p>
<p>2.在webpack.config.js中导入Plugin，通过plugins关键字下进行配置（数组）</p>
<h4 id="5-2-BannerPlugin的配置"><a href="#5-2-BannerPlugin的配置" class="headerlink" title="5.2 BannerPlugin的配置"></a>5.2 BannerPlugin的配置</h4><p>横幅插件，为打包的文件添加版权声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'最终版权归Nabok所有'</span>)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>

<p><img src="E:%5CWebTime%5Cwebpack%5Cimgages%5CBannerPlugin.png" alt="版权声明"></p>
<h4 id="5-3-HtmlWebpackPlugin的配置"><a href="#5-3-HtmlWebpackPlugin的配置" class="headerlink" title="5.3    HtmlWebpackPlugin的配置"></a>5.3    HtmlWebpackPlugin的配置</h4><p>HtmlWebpackPlugin插件可将入口文件index.html打包到发布文件夹dist中</p>
<ul>
<li><p>自动根据指定的模板生成一个index.html文件</p>
</li>
<li><p>自动将打包的js文件通过script标签插入到body中</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line"><span class="number">2.</span></span><br><span class="line"> <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"> </span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'index.html'</span>	<span class="comment">//指定的模板，在当前目录寻找并将其中body的代码引入新的index.html文件</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<h4 id="5-4-uglifyJsPlugin插件的配置"><a href="#5-4-uglifyJsPlugin插件的配置" class="headerlink" title="5.4    uglifyJsPlugin插件的配置"></a>5.4    uglifyJsPlugin插件的配置</h4><p>uglifyjs-webpack-plugin插件用于对js文件进行压缩处理，注意版本兼容问题（1.1.1与CLI2保持一致）</p>
<p>uglify(丑化：压缩-->难看)：去掉空格，替换变量名等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">npm install uglifyjs-webpack-plugin@<span class="number">1.1</span><span class="number">.1</span> --save-dev</span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">const</span> uglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">	<span class="keyword">new</span> uglifyJsPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="6-搭建本地服务器devserver"><a href="#6-搭建本地服务器devserver" class="headerlink" title="6.搭建本地服务器devserver"></a>6.搭建本地服务器devserver</h3><p>本地开发服务器devserver，基于node.js搭建，内部使用express框架，用于监听代码并实时自动刷新浏览器。</p>
<p>根据服务的文件夹，监听代码的变动并实时编译，但不会生成保存在磁盘中，而是缓存在内存中进行测试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>下载安装</span><br><span class="line">npm install --save-dev webpack-dev-server@<span class="number">2.9</span><span class="number">.1</span>	<span class="comment">//2.9.1与CLI2一致</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>webpack.config.js配置</span><br><span class="line">devServer:&#123;</span><br><span class="line">	contentBase: <span class="string">'./dist'</span>,	<span class="comment">//需要提供本地服务的文件夹，默认根目录</span></span><br><span class="line">	inline: <span class="literal">true</span>,	<span class="comment">//页面是否实时刷新</span></span><br><span class="line">	port: <span class="number">8080</span>,		<span class="comment">//端口号，默认8080</span></span><br><span class="line">	historyApiFallback: 	<span class="comment">//SPA应用中依赖HTML5的history模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>本地启动服务器</span><br><span class="line">webpack-dev-server</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>package.json的script配置，简化启动命令</span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open"</span>	<span class="comment">//npm run dev启动本地服务，--open表示直接打开浏览器</span></span><br></pre></td></tr></table></figure>

<h3 id="7-webpack配置文件的分离"><a href="#7-webpack配置文件的分离" class="headerlink" title="7.webpack配置文件的分离"></a>7.webpack配置文件的分离</h3><p>分离webpack.config.js的配置信息，将开发阶段依赖的配置与生产发布时依赖的配置分离，如压缩要在打包时进行</p>
<p>（1）分成三个配置文件，放在build文件夹下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base.config.js：共有的配置信息</span><br><span class="line"></span><br><span class="line">dev.config.js：开发阶段依赖的配置信息</span><br><span class="line"></span><br><span class="line">prod.config.js：生产发布时依赖的配置信息</span><br></pre></td></tr></table></figure>

<p>（2）将配置信息进行合并</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>安装merge</span><br><span class="line">npm install webpack-merge --save-dev</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>导入</span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>合并</span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig,&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> uglifyJsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（3）更改配置信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">命令：</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --config ./build/prod.config.js"</span>,	<span class="comment">//自定义配置文件</span></span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --config ./build/dev.config.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line"> 打包路径：</span><br><span class="line">      output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'../dist'</span>),</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios学习笔记</title>
    <url>/%E7%AC%94%E8%AE%B0/Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Axios学习笔记"><a href="#Axios学习笔记" class="headerlink" title="Axios学习笔记"></a>Axios学习笔记</h2><h3 id="一、网络请求模块"><a href="#一、网络请求模块" class="headerlink" title="一、网络请求模块"></a>一、网络请求模块</h3><p>作用：向服务器<strong>发送网络请求</strong>并对响应的数据进行初步处理。</p>
<h4 id="常用方案"><a href="#常用方案" class="headerlink" title="常用方案"></a>常用方案</h4><p><strong>1.传统Ajax</strong></p>
<p>​    基于XMLHttpRequest（XHR）</p>
<p>​    缺点：配置和调用混乱，编码蛋疼</p>
<p><strong>2.jQuery-Ajax</strong></p>
<p>​    基于jQuery库</p>
<p>​    缺点：要使用jQuery-Ajax的功能要引入整个jQuery库</p>
<p><strong>3.JSONP</strong></p>
<p>​    基于<code>&lt;script&gt;</code>标签的src属性，可解决跨域访问的问题</p>
<p><strong>4.Axios</strong></p>
<p>​    可在node环境使用，支持Promise，可拦截请求和响应并处理其中的数据</p>
<h3 id="二、axios框架基本介绍"><a href="#二、axios框架基本介绍" class="headerlink" title="二、axios框架基本介绍"></a>二、axios框架基本介绍</h3><p>axios可理解为：ajax I/O system</p>
<h4 id="2-1-请求方式"><a href="#2-1-请求方式" class="headerlink" title="2.1 请求方式"></a>2.1 请求方式</h4><ul>
<li>axios(config)</li>
<li>axios.request(config)</li>
<li>axios.get(url[,config])</li>
<li>axios.delete(url[,config])</li>
<li>axios.head(url[,config])</li>
<li>axios.post(url[,data,config])</li>
<li>axios.put(url[,data,config])</li>
<li>axios.patch(url[,data,config])</li>
</ul>
<h3 id="三、axios框架的使用"><a href="#三、axios框架的使用" class="headerlink" title="三、axios框架的使用"></a>三、axios框架的使用</h3><h4 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h4><p>安装axios框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure>

<p>导入axios对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br></pre></td></tr></table></figure>

<p>发起请求，接收响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">axios(&#123;</span><br><span class="line">	url: <span class="string">'https://easy-mock.com/mock/5ec5edace0e3c81a0943e357/home/multidata'</span>,</span><br><span class="line">	method: <span class="string">'get'</span>	<span class="comment">//默认GET请求</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">2.</span></span><br><span class="line">axios(&#123;</span><br><span class="line">	url: <span class="string">'http://123.207.32.32:8000/home/data?type=sell&amp;page=2'</span>,</span><br><span class="line"> <span class="comment">/* GET请求的参数拼接</span></span><br><span class="line"><span class="comment">    params: &#123;</span></span><br><span class="line"><span class="comment">       type: 'pop',</span></span><br><span class="line"><span class="comment">       page: 2</span></span><br><span class="line"><span class="comment">   &#125;,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//注：响应的数据在data选项中</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-发送并发请求"><a href="#3-2-发送并发请求" class="headerlink" title="3.2 发送并发请求"></a>3.2 发送并发请求</h4><p>同时发送多个请求，接收到所有响应的数据后统一进行处理</p>
<ul>
<li>axios.all([])     发送多个请求</li>
<li>axios.spread()    将返回的数组数据展开为多个数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.all([axios.get(<span class="string">'https://easy-mock.com/mock/5ec5edace0e3c81a0943e357/home/multidata'</span>),</span><br><span class="line">       axios.get(<span class="string">'http://123.207.32.32:8000/home/data'</span>,</span><br><span class="line">        &#123;<span class="attr">params</span>: &#123;<span class="attr">type</span>: <span class="string">'pop'</span>,<span class="attr">page</span>: <span class="number">2</span>&#125;&#125;)])</span><br><span class="line"> 	 .then(axios.spread(<span class="function">(<span class="params">res1,res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">	&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-设置axios全局配置"><a href="#3-3-设置axios全局配置" class="headerlink" title="3.3 设置axios全局配置"></a>3.3 设置axios全局配置</h4><p>axios.default是全局默认属性</p>
<p>一般将某些固定的请求数据抽取出来作为全局配置信息添加到axios.default中，如BaseURL、timeout等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios.default.baseURL &#x3D; &#39;https:&#x2F;&#x2F;easy-mock.com&#x2F;mock&#x2F;5ec5edace0e3c81a0943e357&#x2F;home&#39;</span><br><span class="line">axios.default.timeout &#x3D; 5000</span><br><span class="line">axios(&#123;</span><br><span class="line">	url: &#39;&#x2F;multidata&#39;,</span><br><span class="line">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">	console.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>常用配置选项</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: &#39;&#39;		请求地址</span><br><span class="line">method: &#39;&#39;	请求类型</span><br><span class="line">params: &#123; &#125;	URL查询对象&#x2F;GET请求参数</span><br><span class="line">data: &#123; &#125;	请求体</span><br><span class="line">baseURL: &#39;&#39;	根路径</span><br><span class="line">transformRequest: [function(data)&#123; &#125;]	请求前进行数据处理</span><br><span class="line">transformResponse: [function(data)&#123; &#125;]	请求后进行数据处理</span><br><span class="line">headers: &#123;&#39;x-Requested-With&#39;: &#39;XMLHttpRequest&#39;&#125;	自定义请求头</span><br></pre></td></tr></table></figure>

<h4 id="3-4-创建axios实例"><a href="#3-4-创建axios实例" class="headerlink" title="3.4 创建axios实例"></a>3.4 创建axios实例</h4><p>以上例子使用的是默认的全局的axios对象，一般通过创建新的axios实例来发送请求</p>
<p>axios.create(config)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建多个实例并初始化不同的配置信息，根据需求使用对应的实例发送请求</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">	baseURL: <span class="string">'https://easy-mock.com/mock/5ec5edace0e3c81a0943e357'</span>,</span><br><span class="line">   timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> instance2 = axios.create(&#123;</span><br><span class="line">	baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">   timeout: <span class="number">10000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance1(&#123;</span><br><span class="line">	url: <span class="string">'/home/multidata'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">instance2(&#123;</span><br><span class="line">	url: <span class="string">'/home/data'</span>,</span><br><span class="line">   params: &#123;</span><br><span class="line">      type: <span class="string">'pop'</span>,</span><br><span class="line">      page: <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-5-使用axios拦截器"><a href="#3-5-使用axios拦截器" class="headerlink" title="3.5 使用axios拦截器"></a>3.5 使用axios拦截器</h4><p>在发送请求或接收响应后进行二次处理，比如修改config以符合服务器要求，每次发起请求时显示请求动画，携带一些特殊的信息（如token），只返回响应的必要数据（如data）等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拦截请求</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> config	<span class="comment">//返回请求的配置信息</span></span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//拦截响应</span></span><br><span class="line"> instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="四、封装axios模块"><a href="#四、封装axios模块" class="headerlink" title="四、封装axios模块"></a>四、封装axios模块</h3><p>第三方库的维护更新依赖于创造者，没有保证，因此要对axios进行再次封装再导入项目中使用。</p>
<p>结合回调函数或Promise进行封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">封装 request.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://123.207.32.32:8000'</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> instance(config)	<span class="comment">//返回一个Promise对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 main.js</span><br><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">'./request.js'</span></span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">   url: <span class="string">'/home/multidata'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Axios原理解析"><a href="#Axios原理解析" class="headerlink" title="Axios原理解析"></a>Axios原理解析</h3><p>.d.ts文件，底层代码不是js实现，使用TS展示</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS预处理器Less</title>
    <url>/%E7%AC%94%E8%AE%B0/Less/</url>
    <content><![CDATA[<h2 id="CSS预处理器Less"><a href="#CSS预处理器Less" class="headerlink" title="CSS预处理器Less"></a>CSS预处理器Less</h2><p>三种预处理器</p>
<p>Less、Sass、Stylus</p>
<p>作用：方便开发者编写代码，结构更清晰，更简洁，提高编码效率</p>
<h4 id="一-less简介"><a href="#一-less简介" class="headerlink" title="一.less简介"></a>一.less简介</h4><p>less是一种动态样式语言，增加了变量，函数，mixin等特性，既可以在客户端运行，也可以借助node.js在服务器端运行。</p>
<p>官网：<span class="exturl" data-url="aHR0cDovL2xlc3Njc3MuY24v" title="http://lesscss.cn/">http://lesscss.cn/<i class="fa fa-external-link"></i></span></p>
<p>文件后缀为.less，需要编译成css文件方可使用</p>
<h4 id="二-编译方式："><a href="#二-编译方式：" class="headerlink" title="二.编译方式："></a>二.编译方式：</h4><p>1.通过外部编译器，如考拉koala</p>
<p>2.通过命令行，需要安装node.min.js运行环境</p>
<p>3.通过引入less.js脚本文件在线编译（style中type=”text/less”，脚本一般在底部引入)，性能较差</p>
<h4 id="三-注释"><a href="#三-注释" class="headerlink" title="三.注释"></a>三.注释</h4><p>以//开头的注释不会编译到css文件中</p>
<p>以/**/包裹的注释会编译到css文件中</p>
<h4 id="四-变量"><a href="#四-变量" class="headerlink" title="四.变量"></a>四.变量</h4><p>使用@声明变量 @变量名:含义 ，根据变量不同的含义有不同的引用方式：</p>
<p>1.作为普通属性值：直接@color</p>
<p>2.作为选择器或属性名：#@{selector}</p>
<p>3.作为URL：@{url}</p>
<p>变量具有延时加载的特点，在加载完作用域（块级）的代码后再赋值给变量</p>
<h4 id="五-嵌套规则"><a href="#五-嵌套规则" class="headerlink" title="五.嵌套规则"></a>五.嵌套规则</h4><p>1.基本嵌套规则    –    嵌套的双方为HTML的父子关系，编译后的css中两者之间加上空格</p>
<p>2.&amp;的使用    –    在选择器前加上&amp;表示同级</p>
<h4 id="六-混合mixin"><a href="#六-混合mixin" class="headerlink" title="六.混合mixin"></a>六.混合mixin</h4><p>混合就是将一系列属性从一个规则集引入到另一个规则集的方式（相当于ctrl+c和ctrl+v)</p>
<p>使用<code>.</code> 的形式    定义,一般会放在额外的文件夹中作为混合库（API）使用，通过    @import “文件名”    引入。</p>
<p>目的:提高代码的复用率</p>
<p>1.普通混合–混合会编译到css文件中</p>
<p>.center{</p>
<p>margin:auto;</p>
<p>}</p>
<p>2.不带输出混合–混合不会编译到css文件中</p>
<p>.center(){</p>
<p>margin:auto;</p>
<p>}</p>
<p>3.带参数混合</p>
<p>.center(@c){</p>
<p>margin:auto;</p>
<p>background: @c;</p>
<p>}</p>
<p>4.带参数有默认值混合</p>
<p>.center(@c:pink){</p>
<p>margin:auto;</p>
<p>background: @c;</p>
<p>}</p>
<p>5.多个参数混合</p>
<p>.center(@w:100px,@c:pink){</p>
<p>margin:auto;</p>
<p>background: @c;</p>
<p>width: @w;</p>
<p>}</p>
<p>6.命名参数</p>
<p>在引用混合时实参指定变量名</p>
<p>#div{</p>
<p>.center(@c:pink);</p>
<p>}</p>
<p>7.匹配模式</p>
<p>额外定义同名混合，可在括号内插入一个标识符代表某模式，在该混合内部编写其特有的的代码，原混合的第一个参数必须为@_且形参数量与匹配模式的相同</p>
<p>8.arguments变量</p>
<p>实参列表，通过@arguments引用，简写代码</p>
<p>.border(@1,@2,@3){</p>
<p>border:@arguments;</p>
<p>}</p>
<h4 id="七-计算"><a href="#七-计算" class="headerlink" title="七.计算"></a>七.计算</h4><p>加减乘除，不同于css的cacl方法，只需计算的一方带有单位即可</p>
<h4 id="八-继承"><a href="#八-继承" class="headerlink" title="八.继承"></a>八.继承</h4><p>性能比混合高，灵活性较低，与类相似不带参数</p>
<p>：extend(.类名) 表示继承</p>
<p>多个选择器包含公共代码</p>
<h4 id="九-避免编译"><a href="#九-避免编译" class="headerlink" title="九.避免编译"></a>九.避免编译</h4><p>保持代码的原样编译到css中</p>
<p>~”代码”</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONP学习笔记</title>
    <url>/%E7%AC%94%E8%AE%B0/JSONP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JSONP学习笔记"><a href="#JSONP学习笔记" class="headerlink" title="JSONP学习笔记"></a>JSONP学习笔记</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源的定义：如果两个地址的协议，域名和端口都相同，则两者具有相同的源。</p>
<p>同源策略：不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源，这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>限制范围：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1） Cookie、LocalStorage 和 IndexDB 无法读取。</span><br><span class="line">（2） DOM 无法获得。</span><br><span class="line">（3） AJAX 请求不能发送。</span><br></pre></td></tr></table></figure>

<p>不受限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）页面中的链接，重定向以及表单提交。</span><br><span class="line"></span><br><span class="line">（2）凡是拥有”src”这个属性的标签都拥有跨域的能力，如嵌入到页面中的&lt;\script&gt;、&lt;\img&gt;、&lt;\iframe&gt;等。</span><br></pre></td></tr></table></figure>

<h2 id="AJAX的跨域"><a href="#AJAX的跨域" class="headerlink" title="AJAX的跨域"></a>AJAX的跨域</h2><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>基本思想：通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，服务器收到请求后，动态生成JSON文件，将数据放在一个指定名字的回调函数里传回来。</p>
<p>客户端的实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 得到航班信息查询结果后的回调函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> flightHandler = <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'你查询的航班结果是：票价 '</span> + data.price + <span class="string">' 元，'</span> + <span class="string">'余票 '</span> + data.tickets + <span class="string">' 张。'</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> url = <span class="string">"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建script标签，设置其属性</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    script.setAttribute(<span class="string">'src'</span>, url);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 把script标签加入head，此时调用开始</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script); </span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JQuery的jsonp实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot; &gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">     &lt;title&gt;Untitled Page&lt;&#x2F;title&gt;</span><br><span class="line">      &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">      &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">     jQuery(document).ready(function()&#123; </span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">             type: &quot;get&quot;,</span><br><span class="line">             async: false,</span><br><span class="line">             url: &quot;http:&#x2F;&#x2F;flightQuery.com&#x2F;jsonp&#x2F;flightResult.aspx?code&#x3D;CA1998&quot;,</span><br><span class="line">             dataType: &quot;jsonp&quot;,</span><br><span class="line">             jsonp: &quot;callback&quot;,&#x2F;&#x2F;传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)</span><br><span class="line">             jsonpCallback:&quot;flightHandler&quot;,&#x2F;&#x2F;自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据</span><br><span class="line">             success: function(json)&#123;</span><br><span class="line">                 alert(&#39;您查询到航班信息：票价： &#39; + json.price + &#39; 元，余票： &#39; + json.tickets + &#39; 张。&#39;);</span><br><span class="line">             &#125;,</span><br><span class="line">             error: function()&#123;</span><br><span class="line">                 alert(&#39;fail&#39;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">     &lt;&#x2F;script&gt;</span><br><span class="line">     &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&#x2F;&#x2F; 仅仅用于get请求</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/%E7%AC%94%E8%AE%B0/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%88HTTP%20Status%20Code%EF%BC%89/</url>
    <content><![CDATA[<h2 id="HTTP状态码（HTTP-Status-Code）"><a href="#HTTP状态码（HTTP-Status-Code）" class="headerlink" title="HTTP状态码（HTTP Status Code）"></a>HTTP状态码（HTTP Status Code）</h2><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。</p>
<h4 id="常见的HTTP状态码："><a href="#常见的HTTP状态码：" class="headerlink" title="常见的HTTP状态码："></a>常见的HTTP状态码：</h4><ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h4 id="HTTP状态码分类（5种）"><a href="#HTTP状态码分类（5种）" class="headerlink" title="HTTP状态码分类（5种）"></a>HTTP状态码分类（5种）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1**	信息，服务器收到请求，需要请求者继续执行操作</span><br><span class="line">2**	成功，操作被成功接收并处理</span><br><span class="line">3**	重定向，需要进一步的操作以完成请求</span><br><span class="line">4**	客户端错误，请求包含语法错误或无法完成请求</span><br><span class="line">5**	服务器错误，服务器在处理请求的过程中发生了错误</span><br></pre></td></tr></table></figure>

<h4 id="1xx-消息"><a href="#1xx-消息" class="headerlink" title="1xx  消息"></a>1xx  消息</h4><p>临时响应，代表请求已被接受，需要继续处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100——继续，客户端应当继续发送请求</span><br><span class="line"></span><br><span class="line">101——切换协议，服务器根据请求转换HTTP协议版本</span><br><span class="line"></span><br><span class="line">102——由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行</span><br></pre></td></tr></table></figure>

<h4 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx  成功"></a>2xx  成功</h4><p>代表请求已成功被服务器接收并处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200——请求成功，请求所希望的响应头或数据体将随此响应返回，一般用于GET与POST请求</span><br><span class="line"></span><br><span class="line">201——已创建，请求成功并创建了新的资源，新文件的URI 随Location 头信息返回</span><br><span class="line"></span><br><span class="line">202——已接受，已经接受请求，但未处理完成</span><br><span class="line"></span><br><span class="line">203——非授权信息。请求成功，但返回的meta信息不在原始的服务器，而是一个副本</span><br><span class="line"></span><br><span class="line">204——无内容。服务器成功处理请求，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。</span><br><span class="line"></span><br><span class="line">205——重置内容。服务器成功处理请求，未返回内容，但客户端应重置文档视图。可通过此返回码清除浏览器的表单域</span><br><span class="line"></span><br><span class="line">206——部分内容。服务器已经完成了部分GET请求</span><br><span class="line">207——由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息</span><br></pre></td></tr></table></figure>

<h4 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h4><p>代表客户端需要采取进一步的操作才能完成请求，后续的请求地址（重定向目标<br>）在本次响应的 Location 域中指明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">300——多种选择。请求的资源可在多处得到，相应可返回一个资源特征与地址的列表供客户端选择</span><br><span class="line"></span><br><span class="line">301——永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI</span><br><span class="line"></span><br><span class="line">302——临时移动。与301类似，但资源只是临时被移动，客户端应继续使用原有URI</span><br><span class="line"></span><br><span class="line">303——查看其它地址。与301类似，建议客户访问其他URL，使用GET和POST请求查看</span><br><span class="line"></span><br><span class="line">304——未修改。GET 请求已执行，但所请求的资源未修改</span><br><span class="line"></span><br><span class="line">305——使用代理。所请求的资源必须通过代理访问</span><br><span class="line"></span><br><span class="line">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class="line"></span><br><span class="line">307——临时重定向。与302类似，使用GET请求重定向</span><br></pre></td></tr></table></figure>

<h4 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx  客户端错误"></a>4xx  客户端错误</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400——错误请求，如语法错误</span><br><span class="line"></span><br><span class="line">401——请求授权失败，要求用户进行身份认证</span><br><span class="line"></span><br><span class="line">402——保留，将来使用</span><br><span class="line"></span><br><span class="line">403——请求不允许，服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line"></span><br><span class="line">404——服务器无法根据客户端的请求找到资源（网页），广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情</span><br><span class="line">况下。</span><br><span class="line"></span><br><span class="line">405——客户端请求中的方法被禁止</span><br><span class="line"></span><br><span class="line">406——服务器无法根据客户端请求的内容特性完成请求</span><br><span class="line"></span><br><span class="line">407——请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span><br><span class="line"></span><br><span class="line">408——超时，服务器等待客户端发送的请求时间过长</span><br><span class="line"></span><br><span class="line">409——服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</span><br><span class="line"></span><br><span class="line">410——客户端请求的资源已经不存在，包含旧资源失效原因</span><br><span class="line"></span><br><span class="line">411——服务器无法处理客户端发送的不带Content-Length的请求信息</span><br><span class="line"></span><br><span class="line">412——客户端请求信息的先决条件错误</span><br><span class="line"></span><br><span class="line">413——请求的资源大于服务器允许的大小，因此拒绝请求</span><br><span class="line"></span><br><span class="line">414——请求的资源URL长于服务器允许的长度，服务器无法处理</span><br><span class="line"></span><br><span class="line">415——服务器无法处理请求附带的媒体格式</span><br><span class="line"></span><br><span class="line">416——客户端请求的范围无效</span><br><span class="line"></span><br><span class="line">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</span><br></pre></td></tr></table></figure>

<h4 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h4><p>代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">500——服务器内部错误，无法完成请求</span><br><span class="line"></span><br><span class="line">501——服务器不支持请求的功能，无法完成请求</span><br><span class="line"></span><br><span class="line">502——服务器暂时不可用，有时是为了防止发生系统过载</span><br><span class="line"></span><br><span class="line">503——服务器过载或系统维护</span><br><span class="line"></span><br><span class="line">504——充当网关或代理的服务器，未及时从远端服务器获取请求</span><br><span class="line"></span><br><span class="line">505——服务器不支持或拒绝支请求头中指定的HTTP版本</span><br></pre></td></tr></table></figure>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>500错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">500错误是站长经常遇到的问题，就本人的经验，原因及解决方法归纳如下：</span><br><span class="line"></span><br><span class="line">1、运行的用户数过多，对服务器造成的压力过大，服务器无法响应，则报HTTP500错误。</span><br><span class="line"></span><br><span class="line">这个原因是网站报500错误的最主要原因，很多网站为什么突然会报500错误（service unavailable）呢？90%是由于空间压力过大，超出了空间商设定的上限而造成的。</span><br><span class="line"></span><br><span class="line">遇到这个问题，最好是第一时间找到空间商的售后服务，他们一般会帮你回收一下应用程序池，问题便得到解决。如果没有找到售后服务，可以自己在空间管理后台，找到“回收应用程序池”那个项目，自己手动执行一下即可。不过，一些空间管理后台并没有提供该项服务。</span><br><span class="line"></span><br><span class="line">2、如果排除了第1的可能性，那么很大原因便是程序上出现了问题。</span><br><span class="line"></span><br><span class="line">可以做个简单的测试页面，看是否能运行成功，再检测报错的页面，从而针对性的进行修改。</span><br><span class="line"></span><br><span class="line">该做关联的地方没有去做关联，则报HTTP500错误。进行手工或者自动关联，问题得到解决。</span><br><span class="line"></span><br><span class="line">3、如果测试中所进行的操作需要向数据库中插入数据，若大数据量的情况下导致数据库中表空间已满，或者缓冲池较小无法满足数据的存取等，都有可能导致HTTP500错误。</span><br><span class="line"></span><br><span class="line">解决方法是调整数据库、修改连接池大小等等，根据个人具体情况进行修正即可。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Stylus学习笔记</title>
    <url>/%E7%AC%94%E8%AE%B0/Stylus/</url>
    <content><![CDATA[<h1 id="Stylus学习笔记"><a href="#Stylus学习笔记" class="headerlink" title="Stylus学习笔记"></a>Stylus学习笔记</h1><ul>
<li>配置好环境，保证能正常使用Stylus</li>
<li>学习Stylus的基础语法</li>
<li>在开发中使用Stylus的便捷特性</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个哥们儿学名叫 stylus，是 CSS 的预处理框架。</p>
<p>CSS 预处理，顾名思义，预先处理 CSS。那 stylus 咋预先处理呢？stylus 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，执行这一套骚操作之后，这个文件可编译成 CSS 文件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，安装 stylus（确保之前已经安装 nodejs ）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install stylus</span></span><br></pre></td></tr></table></figure>

<p>安装之后，运行 <code>stylus -h</code> 可查看帮助。<br>运行 <code>stylus example.styl</code> 可将 demo.styl 文件编译成 example.css 文件。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>一段简单的 stylus 代码：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$background</span>-<span class="attribute">color</span> = lightblue</span><br><span class="line">add (<span class="selector-tag">a</span>, <span class="selector-tag">b</span> = a)</span><br><span class="line">    <span class="selector-tag">a</span> = unit(<span class="selector-tag">a</span>, px)</span><br><span class="line">    <span class="selector-tag">b</span> = unit(<span class="selector-tag">b</span>, px)</span><br><span class="line">    <span class="selector-tag">a</span> + b</span><br><span class="line"></span><br><span class="line">.list-item</span><br><span class="line">.text-box</span><br><span class="line">    span</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="variable">$background</span>-color</span><br><span class="line">        <span class="attribute">margin</span>: add(<span class="number">10</span>)</span><br><span class="line">        <span class="attribute">padding</span>: add(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">    &amp;:hover</span><br><span class="line">        <span class="attribute">background-color</span>: powderblue</span><br></pre></td></tr></table></figure>

<p>编译后生成的 CSS 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-item</span> <span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-class">.text-box</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#add8e6</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-item</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.text-box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此我们看到了 stylus 代码以及由它编译而成的 CSS 代码,下面来一步一步看一看为啥编译成这样。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$background</span>-<span class="attribute">color</span> = lightblue</span><br></pre></td></tr></table></figure>

<p>上面的代码声明了变量 <code>$background-color</code>,并为其赋值 <code>lightblue</code>。<br>声明之后，就可以使用这个变量了：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">span</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$background</span>-color</span><br></pre></td></tr></table></figure>

<p>翻译成 CSS 就是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">add (<span class="selector-tag">a</span>, <span class="selector-tag">b</span> = a)</span><br><span class="line">    <span class="selector-tag">a</span> = unit(<span class="selector-tag">a</span>, px)</span><br><span class="line">    <span class="selector-tag">b</span> = unit(<span class="selector-tag">b</span>, px)</span><br><span class="line">    <span class="selector-tag">a</span> + b</span><br></pre></td></tr></table></figure>

<p>代码声明了函数 <code>add</code>, <code>add</code> 接受两个参数 <code>a</code> 和 <code>b</code>，其中 <code>b</code> 的默认值是 <code>a</code>。<br><code>add</code> 中调用了 stylus 的内置函数 <code>unit</code>，此处，<code>unit</code> 函数为 <code>a</code> 和 <code>b</code>赋予了单位 <code>px</code>。<br>最后将 <code>a</code> 和 <code>b</code> 相加，并返回结果，是的，你没有看错，没有 <code>return</code>，但是返回了结果。<br><code>return</code> 居然是可以省略的，很任性了。</p>
<p>函数调用：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">span</span><br><span class="line">    <span class="attribute">margin</span>: add(<span class="number">10</span>)</span><br><span class="line">    <span class="attribute">padding</span>: add(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>翻译成 CSS 就是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.list-item</span><br><span class="line">.text-box</span><br><span class="line">    span</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="variable">$background</span>-color</span><br><span class="line">        <span class="attribute">margin</span>: add(<span class="number">10</span>)</span><br><span class="line">        <span class="attribute">padding</span>: add(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">    &amp;:hover</span><br><span class="line">        <span class="attribute">background-color</span>: powderblue</span><br></pre></td></tr></table></figure>

<p>这一段是与 CSS 代码长得最像的了，虽说最为相像，可有些差别还是一眼就能看出的。<br>比如没有了 CSS 的花括号，没有了 CSS 的分号，却多了一些奇奇怪怪的缩进，还有那个 <code>&amp;</code> 是什么鬼？还 <code>&amp;:hover</code> ???<br>预知后事如何，这次接着分解。</p>
<p>先说符号，这里提到的花括号和分号在stylus中是可以省略的，不仅如此，冒号也是可以省略的，<code>color: powderblue</code> 你可以写成 <code>color powderblue</code>,没有问题。</p>
<p>再说缩进，先提出两个有缩进关系的选择器，上面代码片段第二行的 <code>.text-box</code> 和第三行的 <code>span</code>，其实很容易理解，这哥俩写到 CSS 里面是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">.text-box span&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>即 <code>span</code> 是 <code>.text-box</code> 的子选择器，stylus 中以缩进表示这种关系，更加清晰明了，好看。</p>
<p>还有 <code>&amp;</code>，这是个新鲜东西。它是父级的引用，还是来看代码。</p>
<p>stylus这样写:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.list-item</span><br><span class="line">.text-box</span><br><span class="line">    &amp;:hover</span><br><span class="line">        <span class="attribute">background-color</span>: powderblue</span><br></pre></td></tr></table></figure>

<p>翻译成 CSS 是这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-item</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.text-box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#b0e0e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信代码中已经能很明确地体现出 <code>&amp;</code> 父级引用的角色了。<br>同时，我们也不难看出，<code>.list-item</code> 和 <code>.text-box</code> 这两个同一级的选择器在 stylus 中是可以换行写的，只要保证缩进相同，它们就属于同一级的选择器。当然，沿用 CSS 的方式，将同一级的选择器用逗号分隔开在 stylus 中也是可以的。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Stylus</tag>
      </tags>
  </entry>
</search>
